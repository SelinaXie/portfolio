var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import { createURLDescriptor, joinPaths, modifyTrailingSlash } from 'navi';
import { NaviContext } from './NaviContext';
import { scrollToHash } from './scrollToHash';
export var LinkContext = React.createContext(undefined);
var LinkAnchor = /** @class */ (function (_super) {
    __extends(LinkAnchor, _super);
    function LinkAnchor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.renderChildren = function (context) {
            var handleClick = context.onClick;
            if (_this.props.onClick) {
                handleClick = function (e) {
                    _this.props.onClick(e);
                    if (!e.defaultPrevented) {
                        context.onClick(e);
                    }
                };
            }
            return (React.createElement("a", __assign({}, context, _this.props, { onClick: handleClick })));
        };
        return _this;
    }
    LinkAnchor.prototype.render = function () {
        return React.createElement(LinkContext.Consumer, { children: this.renderChildren });
    };
    return LinkAnchor;
}(React.Component));
export { LinkAnchor };
// Need to include this type definition, as the automatically generated one
// is incompatible with some versions of the react typings.
export var Link = Object.assign(React.forwardRef(function (props, anchorRef) { return (React.createElement(NaviContext.Consumer, null, function (context) { return React.createElement(InnerLink, __assign({}, props, { context: context, anchorRef: anchorRef })); })); }), { Anchor: LinkAnchor });
Link.defaultProps = {
    render: function (props) {
        var active = props.active, activeClassName = props.activeClassName, activeStyle = props.activeStyle, children = props.children, className = props.className, hidden = props.hidden, style = props.style;
        return (React.createElement(LinkAnchor, { children: children, className: (className || '') + " " + ((active && activeClassName) || ''), hidden: hidden, style: Object.assign({}, style, active ? activeStyle : {}) }));
    },
};
var InnerLink = /** @class */ (function (_super) {
    __extends(InnerLink, _super);
    function InnerLink(props) {
        var _this = _super.call(this, props) || this;
        _this.handleClick = function (event) {
            // Let the browser handle the event directly if:
            // - The user used the middle/right mouse button
            // - The user was holding a modifier key
            // - A `target` property is set (which may cause the browser to open the
            //   link in another tab)
            if (event.button === 0 &&
                !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)) {
                if (_this.props.disabled) {
                    event.preventDefault();
                    return;
                }
                if (_this.props.onClick) {
                    _this.props.onClick(event);
                }
                // Let the browser handle targets natively
                if (_this.props.target) {
                    return;
                }
                var url = _this.getURL();
                if (!event.defaultPrevented && url) {
                    event.preventDefault();
                    var currentURL = (_this.props.context.busyRoute || _this.props.context.steadyRoute).url;
                    var isSamePathname = modifyTrailingSlash(url.pathname, 'remove') === modifyTrailingSlash(currentURL.pathname, 'remove');
                    _this.props.context.navigation.navigate(url);
                    if ((isSamePathname || url.pathname === '') && url.hash === currentURL.hash && url.hash) {
                        scrollToHash(currentURL.hash, 'smooth');
                    }
                }
            }
        };
        var url = _this.getURL();
        var navigation = props.context.navigation;
        if (navigation && url && url.pathname && props.prefetch) {
            navigation.prefetch(url).catch(function (e) {
                console.warn("A <Link> tried to prefetch \"" + url.pathname + "\", but the " +
                    "router was unable to fetch this path.");
            });
        }
        return _this;
    }
    InnerLink.prototype.getNavigationURL = function () {
        var context = this.props.context;
        var route = (context.steadyRoute || context.busyRoute);
        return route && route.url;
    };
    InnerLink.prototype.getURL = function () {
        var href = this.props.href;
        // If this is an external link, return undefined so that the native
        // response will be used.
        if (!href || (typeof href === 'string' && ((href.indexOf('://') !== -1 || href.indexOf('mailto:') === 0)))) {
            return;
        }
        // Resolve relative to the current "directory"
        var navigationURL = this.getNavigationURL();
        if (navigationURL && typeof href === 'string') {
            href = href[0] === '/' ? href : joinPaths('/', navigationURL.pathname, href);
        }
        return createURLDescriptor(href);
    };
    InnerLink.prototype.render = function () {
        var _a = this.props, active = _a.active, activeStyle = _a.activeStyle, activeClassName = _a.activeClassName, anchorRef = _a.anchorRef, onClick = _a.onClick, prefetch = _a.prefetch, render = _a.render, exact = _a.exact, props = __rest(_a, ["active", "activeStyle", "activeClassName", "anchorRef", "onClick", "prefetch", "render", "exact"]);
        var navigationURL = this.getNavigationURL();
        var linkURL = this.getURL();
        active = active !== undefined ? active : !!(linkURL &&
            navigationURL &&
            (exact
                ? linkURL.pathname === navigationURL.pathname
                : modifyTrailingSlash(navigationURL.pathname, 'add').indexOf(linkURL.pathname) === 0));
        var context = __assign({}, props, { onClick: this.handleClick, ref: anchorRef, href: typeof props.href === 'string' ? props.href : (linkURL ? linkURL.href : '') });
        return (React.createElement(LinkContext.Provider, { value: context }, render({
            active: active,
            activeClassName: activeClassName,
            activeStyle: activeStyle,
            anchorProps: context,
            children: props.children,
            className: props.className,
            disabled: props.disabled,
            tabIndex: props.tabIndex,
            hidden: props.hidden,
            href: linkURL ? linkURL.href : props.href,
            id: props.id,
            lang: props.lang,
            style: props.style,
            target: props.target,
            title: props.title,
            onClick: this.handleClick,
        })));
    };
    return InnerLink;
}(React.Component));
//# sourceMappingURL=Link.js.map