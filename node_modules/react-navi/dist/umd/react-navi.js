(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('navi')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'navi'], factory) :
    (global = global || self, factory(global.ReactNavi = {}, global.React, global.Navi));
}(this, function (exports, React, navi) { 'use strict';

    var React__default = 'default' in React ? React['default'] : React;

    var NaviContext = React.createContext({});
    var NavConsumer = NaviContext.Consumer;
    var NavContextProvider = NaviContext.Provider;

    function scrollToHash(hash, behavior) {
        if (hash) {
            var id = document.getElementById(hash.slice(1));
            if (id) {
                var _a = id.getBoundingClientRect(), top_1 = _a.top, left = _a.left;
                try {
                    window.scroll({
                        top: top_1 + window.pageYOffset,
                        left: left + window.pageXOffset,
                        behavior: behavior,
                    });
                }
                catch (err) {
                    window.scroll(left + window.pageXOffset, top_1 + window.pageYOffset);
                }
                // Focus the element, as default behavior is cancelled.
                // https://css-tricks.com/snippets/jquery/smooth-scrolling/
                id.focus();
            }
        }
        else {
            window.scroll({
                top: 0,
                left: 0,
                behavior: behavior,
            });
        }
    }

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var LinkContext = React.createContext(undefined);
    var LinkAnchor = /** @class */ (function (_super) {
        __extends(LinkAnchor, _super);
        function LinkAnchor() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.renderChildren = function (context) {
                var handleClick = context.onClick;
                if (_this.props.onClick) {
                    handleClick = function (e) {
                        _this.props.onClick(e);
                        if (!e.defaultPrevented) {
                            context.onClick(e);
                        }
                    };
                }
                return (React.createElement("a", __assign({}, context, _this.props, { onClick: handleClick })));
            };
            return _this;
        }
        LinkAnchor.prototype.render = function () {
            return React.createElement(LinkContext.Consumer, { children: this.renderChildren });
        };
        return LinkAnchor;
    }(React.Component));
    // Need to include this type definition, as the automatically generated one
    // is incompatible with some versions of the react typings.
    var Link = Object.assign(React.forwardRef(function (props, anchorRef) { return (React.createElement(NaviContext.Consumer, null, function (context) { return React.createElement(InnerLink, __assign({}, props, { context: context, anchorRef: anchorRef })); })); }), { Anchor: LinkAnchor });
    Link.defaultProps = {
        render: function (props) {
            var active = props.active, activeClassName = props.activeClassName, activeStyle = props.activeStyle, children = props.children, className = props.className, hidden = props.hidden, style = props.style;
            return (React.createElement(LinkAnchor, { children: children, className: (className || '') + " " + ((active && activeClassName) || ''), hidden: hidden, style: Object.assign({}, style, active ? activeStyle : {}) }));
        },
    };
    var InnerLink = /** @class */ (function (_super) {
        __extends(InnerLink, _super);
        function InnerLink(props) {
            var _this = _super.call(this, props) || this;
            _this.handleClick = function (event) {
                // Let the browser handle the event directly if:
                // - The user used the middle/right mouse button
                // - The user was holding a modifier key
                // - A `target` property is set (which may cause the browser to open the
                //   link in another tab)
                if (event.button === 0 &&
                    !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)) {
                    if (_this.props.disabled) {
                        event.preventDefault();
                        return;
                    }
                    if (_this.props.onClick) {
                        _this.props.onClick(event);
                    }
                    // Let the browser handle targets natively
                    if (_this.props.target) {
                        return;
                    }
                    var url = _this.getURL();
                    if (!event.defaultPrevented && url) {
                        event.preventDefault();
                        var currentURL = (_this.props.context.busyRoute || _this.props.context.steadyRoute).url;
                        var isSamePathname = navi.modifyTrailingSlash(url.pathname, 'remove') === navi.modifyTrailingSlash(currentURL.pathname, 'remove');
                        _this.props.context.navigation.navigate(url);
                        if ((isSamePathname || url.pathname === '') && url.hash === currentURL.hash && url.hash) {
                            scrollToHash(currentURL.hash, 'smooth');
                        }
                    }
                }
            };
            var url = _this.getURL();
            var navigation = props.context.navigation;
            if (navigation && url && url.pathname && props.prefetch) {
                navigation.prefetch(url).catch(function (e) {
                    console.warn("A <Link> tried to prefetch \"" + url.pathname + "\", but the " +
                        "router was unable to fetch this path.");
                });
            }
            return _this;
        }
        InnerLink.prototype.getNavigationURL = function () {
            var context = this.props.context;
            var route = (context.steadyRoute || context.busyRoute);
            return route && route.url;
        };
        InnerLink.prototype.getURL = function () {
            var href = this.props.href;
            // If this is an external link, return undefined so that the native
            // response will be used.
            if (!href || (typeof href === 'string' && ((href.indexOf('://') !== -1 || href.indexOf('mailto:') === 0)))) {
                return;
            }
            // Resolve relative to the current "directory"
            var navigationURL = this.getNavigationURL();
            if (navigationURL && typeof href === 'string') {
                href = href[0] === '/' ? href : navi.joinPaths('/', navigationURL.pathname, href);
            }
            return navi.createURLDescriptor(href);
        };
        InnerLink.prototype.render = function () {
            var _a = this.props, active = _a.active, activeStyle = _a.activeStyle, activeClassName = _a.activeClassName, anchorRef = _a.anchorRef, onClick = _a.onClick, prefetch = _a.prefetch, render = _a.render, exact = _a.exact, props = __rest(_a, ["active", "activeStyle", "activeClassName", "anchorRef", "onClick", "prefetch", "render", "exact"]);
            var navigationURL = this.getNavigationURL();
            var linkURL = this.getURL();
            active = active !== undefined ? active : !!(linkURL &&
                navigationURL &&
                (exact
                    ? linkURL.pathname === navigationURL.pathname
                    : navi.modifyTrailingSlash(navigationURL.pathname, 'add').indexOf(linkURL.pathname) === 0));
            var context = __assign({}, props, { onClick: this.handleClick, ref: anchorRef, href: typeof props.href === 'string' ? props.href : (linkURL ? linkURL.href : '') });
            return (React.createElement(LinkContext.Provider, { value: context }, render({
                active: active,
                activeClassName: activeClassName,
                activeStyle: activeStyle,
                anchorProps: context,
                children: props.children,
                className: props.className,
                disabled: props.disabled,
                tabIndex: props.tabIndex,
                hidden: props.hidden,
                href: linkURL ? linkURL.href : props.href,
                id: props.id,
                lang: props.lang,
                style: props.style,
                target: props.target,
                title: props.title,
                onClick: this.handleClick,
            })));
        };
        return InnerLink;
    }(React.Component));

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NaviProvider = /** @class */ (function (_super) {
        __extends$1(NaviProvider, _super);
        function NaviProvider(props) {
            var _this = _super.call(this, props) || this;
            _this.handleNavigationSnapshot = function (route) {
                if (route.type !== 'busy') {
                    _this.setState({
                        steadyRoute: route,
                        busyRoute: undefined,
                    });
                }
                else {
                    _this.setState({
                        busyRoute: route,
                    });
                }
            };
            _this.handleError = function (error) {
                throw error;
            };
            _this.state = {};
            return _this;
        }
        NaviProvider.getDerivedStateFromProps = function (props, state) {
            if (state.navigation !== props.navigation) {
                var route = props.navigation.getCurrentValue();
                return ((route.type === 'busy')
                    ? { steadyRoute: state.steadyRoute, busyRoute: route, navigation: props.navigation }
                    : { steadyRoute: route, busyRoute: undefined, navigation: props.navigation });
            }
            return null;
        };
        NaviProvider.prototype.render = function () {
            return (React.createElement(NaviContext.Provider, { value: this.state }, this.props.children));
        };
        NaviProvider.prototype.componentDidMount = function () {
            this.subscribe();
        };
        NaviProvider.prototype.componentDidUpdate = function (prevProps) {
            if (prevProps.navigation !== this.props.navigation) {
                this.unsubscribe();
                this.subscribe();
            }
        };
        NaviProvider.prototype.componentWillUnmount = function () {
            this.unsubscribe();
        };
        NaviProvider.prototype.subscribe = function () {
            if (!this.props.navigation) {
                throw new Error("A <NaviProvider> component must receive a \"navigation\" prop.");
            }
            this.subscription = this.props.navigation.subscribe(this.handleNavigationSnapshot, this.handleError);
        };
        NaviProvider.prototype.unsubscribe = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
                delete this.subscription;
            }
        };
        return NaviProvider;
    }(React.Component));

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (undefined && undefined.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    var NotFoundBoundary = function ErrorBoundary(props) {
        return (React.createElement(NaviContext.Consumer, null, function (context) { return React.createElement(InnerNotFoundBoundary, __assign$1({ context: context }, props)); }));
    };
    var InnerNotFoundBoundary = /** @class */ (function (_super) {
        __extends$2(InnerNotFoundBoundary, _super);
        function InnerNotFoundBoundary(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {};
            return _this;
        }
        InnerNotFoundBoundary.getDerivedStateFromProps = function (props, state) {
            if (state.error && props.context.steadyRoute.url.pathname !== state.errorPathname) {
                return {
                    error: undefined,
                    errorPathname: undefined,
                    errorInfo: undefined,
                };
            }
            return null;
        };
        InnerNotFoundBoundary.prototype.componentDidCatch = function (error, errorInfo) {
            if (error instanceof navi.NotFoundError) {
                this.setState({
                    error: error,
                    errorInfo: errorInfo,
                    errorPathname: this.props.context.steadyRoute.url.pathname,
                });
            }
            else {
                throw error;
            }
        };
        InnerNotFoundBoundary.prototype.componentDidUpdate = function (prevProps, prevState) {
            if (this.state.error && !prevState.error) ;
        };
        InnerNotFoundBoundary.prototype.render = function () {
            if (this.state.error) {
                return this.props.render(this.state.error);
            }
            return this.props.children;
        };
        return InnerNotFoundBoundary;
    }(React.Component));

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var reactIs_production_min = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports,"__esModule",{value:!0});
    var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.memo"):
    60115,r=b?Symbol.for("react.lazy"):60116;function t(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case r:case q:case d:return u}}}function v(a){return t(a)===m}exports.typeOf=t;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;
    exports.Fragment=e;exports.Lazy=r;exports.Memo=q;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===r||a.$$typeof===q||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||t(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return t(a)===k};
    exports.isContextProvider=function(a){return t(a)===h};exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return t(a)===n};exports.isFragment=function(a){return t(a)===e};exports.isLazy=function(a){return t(a)===r};exports.isMemo=function(a){return t(a)===q};exports.isPortal=function(a){return t(a)===d};exports.isProfiler=function(a){return t(a)===g};exports.isStrictMode=function(a){return t(a)===f};
    exports.isSuspense=function(a){return t(a)===p};
    });

    unwrapExports(reactIs_production_min);
    var reactIs_production_min_1 = reactIs_production_min.typeOf;
    var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
    var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
    var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
    var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
    var reactIs_production_min_6 = reactIs_production_min.Element;
    var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
    var reactIs_production_min_8 = reactIs_production_min.Fragment;
    var reactIs_production_min_9 = reactIs_production_min.Lazy;
    var reactIs_production_min_10 = reactIs_production_min.Memo;
    var reactIs_production_min_11 = reactIs_production_min.Portal;
    var reactIs_production_min_12 = reactIs_production_min.Profiler;
    var reactIs_production_min_13 = reactIs_production_min.StrictMode;
    var reactIs_production_min_14 = reactIs_production_min.Suspense;
    var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
    var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
    var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
    var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
    var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
    var reactIs_production_min_20 = reactIs_production_min.isElement;
    var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
    var reactIs_production_min_22 = reactIs_production_min.isFragment;
    var reactIs_production_min_23 = reactIs_production_min.isLazy;
    var reactIs_production_min_24 = reactIs_production_min.isMemo;
    var reactIs_production_min_25 = reactIs_production_min.isPortal;
    var reactIs_production_min_26 = reactIs_production_min.isProfiler;
    var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
    var reactIs_production_min_28 = reactIs_production_min.isSuspense;

    var reactIs_development = createCommonjsModule(function (module, exports) {



    {
      (function() {

    Object.defineProperty(exports, '__esModule', { value: true });

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol.for;

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' ||
      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
    }

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function () {};

    {
      var printWarning = function (format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function (condition, format) {
        if (format === undefined) {
          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;
              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_LAZY_TYPE:
          case REACT_MEMO_TYPE:
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    }

    // AsyncMode is deprecated along with isAsyncMode
    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;

    var hasWarnedAboutDeprecatedIsAsyncMode = false;

    // AsyncMode should be deprecated
    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true;
          lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    exports.typeOf = typeOf;
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isValidElementType = isValidElementType;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
      })();
    }
    });

    unwrapExports(reactIs_development);
    var reactIs_development_1 = reactIs_development.typeOf;
    var reactIs_development_2 = reactIs_development.AsyncMode;
    var reactIs_development_3 = reactIs_development.ConcurrentMode;
    var reactIs_development_4 = reactIs_development.ContextConsumer;
    var reactIs_development_5 = reactIs_development.ContextProvider;
    var reactIs_development_6 = reactIs_development.Element;
    var reactIs_development_7 = reactIs_development.ForwardRef;
    var reactIs_development_8 = reactIs_development.Fragment;
    var reactIs_development_9 = reactIs_development.Lazy;
    var reactIs_development_10 = reactIs_development.Memo;
    var reactIs_development_11 = reactIs_development.Portal;
    var reactIs_development_12 = reactIs_development.Profiler;
    var reactIs_development_13 = reactIs_development.StrictMode;
    var reactIs_development_14 = reactIs_development.Suspense;
    var reactIs_development_15 = reactIs_development.isValidElementType;
    var reactIs_development_16 = reactIs_development.isAsyncMode;
    var reactIs_development_17 = reactIs_development.isConcurrentMode;
    var reactIs_development_18 = reactIs_development.isContextConsumer;
    var reactIs_development_19 = reactIs_development.isContextProvider;
    var reactIs_development_20 = reactIs_development.isElement;
    var reactIs_development_21 = reactIs_development.isForwardRef;
    var reactIs_development_22 = reactIs_development.isFragment;
    var reactIs_development_23 = reactIs_development.isLazy;
    var reactIs_development_24 = reactIs_development.isMemo;
    var reactIs_development_25 = reactIs_development.isPortal;
    var reactIs_development_26 = reactIs_development.isProfiler;
    var reactIs_development_27 = reactIs_development.isStrictMode;
    var reactIs_development_28 = reactIs_development.isSuspense;

    var reactIs = createCommonjsModule(function (module) {

    {
      module.exports = reactIs_development;
    }
    });

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

    var ReactPropTypesSecret_1 = ReactPropTypesSecret;

    var printWarning = function() {};

    {
      var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
      var loggedTypeFailures = {};
      var has = Function.call.bind(Object.prototype.hasOwnProperty);

      printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };
    }

    /**
     * Assert that the values match with the type specs.
     * Error messages are memorized and will only be shown once.
     *
     * @param {object} typeSpecs Map of name to a ReactPropType
     * @param {object} values Runtime values that need to be type-checked
     * @param {string} location e.g. "prop", "context", "child context"
     * @param {string} componentName Name of the component for error messages.
     * @param {?Function} getStack Returns the component stack.
     * @private
     */
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                var err = Error(
                  (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
                  'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
                );
                err.name = 'Invariant Violation';
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || 'React class') + ': type specification of ' +
                location + ' `' + typeSpecName + '` is invalid; the type checker ' +
                'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
                'You may have forgotten to pass an argument to the type checker ' +
                'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                'shape all require an argument).'
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error.message] = true;

              var stack = getStack ? getStack() : '';

              printWarning(
                'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
              );
            }
          }
        }
      }
    }

    /**
     * Resets warning cache when testing.
     *
     * @private
     */
    checkPropTypes.resetWarningCache = function() {
      {
        loggedTypeFailures = {};
      }
    };

    var checkPropTypes_1 = checkPropTypes;

    var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
    var printWarning$1 = function() {};

    {
      printWarning$1 = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };
    }

    function emptyFunctionThatReturnsNull() {
      return null;
    }

    var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
      /* global Symbol */
      var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

      /**
       * Returns the iterator method function contained on the iterable object.
       *
       * Be sure to invoke the function with the iterable as context:
       *
       *     var iteratorFn = getIteratorFn(myIterable);
       *     if (iteratorFn) {
       *       var iterator = iteratorFn.call(myIterable);
       *       ...
       *     }
       *
       * @param {?object} maybeIterable
       * @return {?function}
       */
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
          return iteratorFn;
        }
      }

      /**
       * Collection of methods that allow declaration and validation of props that are
       * supplied to React components. Example usage:
       *
       *   var Props = require('ReactPropTypes');
       *   var MyArticle = React.createClass({
       *     propTypes: {
       *       // An optional string prop named "description".
       *       description: Props.string,
       *
       *       // A required enum prop named "category".
       *       category: Props.oneOf(['News','Photos']).isRequired,
       *
       *       // A prop named "dialog" that requires an instance of Dialog.
       *       dialog: Props.instanceOf(Dialog).isRequired
       *     },
       *     render: function() { ... }
       *   });
       *
       * A more formal specification of how these methods are used:
       *
       *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
       *   decl := ReactPropTypes.{type}(.isRequired)?
       *
       * Each and every declaration produces a function with the same signature. This
       * allows the creation of custom validation functions. For example:
       *
       *  var MyLink = React.createClass({
       *    propTypes: {
       *      // An optional string or URI prop named "href".
       *      href: function(props, propName, componentName) {
       *        var propValue = props[propName];
       *        if (propValue != null && typeof propValue !== 'string' &&
       *            !(propValue instanceof URI)) {
       *          return new Error(
       *            'Expected a string or an URI for ' + propName + ' in ' +
       *            componentName
       *          );
       *        }
       *      }
       *    },
       *    render: function() {...}
       *  });
       *
       * @internal
       */

      var ANONYMOUS = '<<anonymous>>';

      // Important!
      // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),

        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker,
      };

      /**
       * inlined Object.is polyfill to avoid requiring consumers ship their own
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
       */
      /*eslint-disable no-self-compare*/
      function is(x, y) {
        // SameValue algorithm
        if (x === y) {
          // Steps 1-5, 7-10
          // Steps 6.b-6.e: +0 != -0
          return x !== 0 || 1 / x === 1 / y;
        } else {
          // Step 6.a: NaN == NaN
          return x !== x && y !== y;
        }
      }
      /*eslint-enable no-self-compare*/

      /**
       * We use an Error-like object for backward compatibility as people may call
       * PropTypes directly and inspect their output. However, we don't use real
       * Errors anymore. We don't inspect their stack anyway, and creating them
       * is prohibitively expensive if they are created too often, such as what
       * happens in oneOfType() for any type before the one that matched.
       */
      function PropTypeError(message) {
        this.message = message;
        this.stack = '';
      }
      // Make `instanceof Error` still work for returned errors.
      PropTypeError.prototype = Error.prototype;

      function createChainableTypeChecker(validate) {
        {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;

          if (secret !== ReactPropTypesSecret_1) {
            if (throwOnDirectAccess) {
              // New behavior only for users of `prop-types` package
              var err = new Error(
                'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                'Use `PropTypes.checkPropTypes()` to call them. ' +
                'Read more at http://fb.me/use-check-prop-types'
              );
              err.name = 'Invariant Violation';
              throw err;
            } else if (typeof console !== 'undefined') {
              // Old behavior for people using React.PropTypes
              var cacheKey = componentName + ':' + propName;
              if (
                !manualPropTypeCallCache[cacheKey] &&
                // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3
              ) {
                printWarning$1(
                  'You are manually calling a React.PropTypes validation ' +
                  'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
                  'and will throw in the standalone `prop-types` package. ' +
                  'You may be seeing this warning due to a third-party PropTypes ' +
                  'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
              }
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }

        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);

        return chainedCheckType;
      }

      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            // `propValue` being instance of, say, date/regexp, pass the 'object'
            // check, but we can offer a more precise error message here rather than
            // 'of type `object`'.
            var preciseType = getPreciseType(propValue);

            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }

      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!reactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          {
            if (arguments.length > 1) {
              printWarning$1(
                'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
                'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
              );
            } else {
              printWarning$1('Invalid argument supplied to oneOf, expected an array.');
            }
          }
          return emptyFunctionThatReturnsNull;
        }

        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }

          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === 'symbol') {
              return String(value);
            }
            return value;
          });
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
      }

      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
          }
          for (var key in propValue) {
            if (has$1(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.');
          return emptyFunctionThatReturnsNull;
        }

        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== 'function') {
            printWarning$1(
              'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
              'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
            );
            return emptyFunctionThatReturnsNull;
          }
        }

        function validate(props, propName, componentName, location, propFullName) {
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
              return null;
            }
          }

          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
        }
        return createChainableTypeChecker(validate);
      }

      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (!checker) {
              continue;
            }
            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
          }
          // We need to check all keys in case some are required but missing from
          // props.
          var allKeys = objectAssign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (!checker) {
              return new PropTypeError(
                'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
                '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
                '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
            if (error) {
              return error;
            }
          }
          return null;
        }

        return createChainableTypeChecker(validate);
      }

      function isNode(propValue) {
        switch (typeof propValue) {
          case 'number':
          case 'string':
          case 'undefined':
            return true;
          case 'boolean':
            return !propValue;
          case 'object':
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }

            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                // Iterator will provide entry [k,v] tuples rather than values.
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }

            return true;
          default:
            return false;
        }
      }

      function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
          return true;
        }

        // falsy value can't be a Symbol
        if (!propValue) {
          return false;
        }

        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
          return true;
        }

        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
          return true;
        }

        return false;
      }

      // Equivalent of `typeof` but with special handling for array and regexp.
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return 'array';
        }
        if (propValue instanceof RegExp) {
          // Old webkits (at least until Android 4.0) return 'function' rather than
          // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
          // passes PropTypes.object.
          return 'object';
        }
        if (isSymbol(propType, propValue)) {
          return 'symbol';
        }
        return propType;
      }

      // This handles more types than `getPropType`. Only used for error messages.
      // See `createPrimitiveTypeChecker`.
      function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
          return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
          if (propValue instanceof Date) {
            return 'date';
          } else if (propValue instanceof RegExp) {
            return 'regexp';
          }
        }
        return propType;
      }

      // Returns a string that is postfixed to a warning about an invalid type.
      // For example, "undefined" or "of type array"
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case 'array':
          case 'object':
            return 'an ' + type;
          case 'boolean':
          case 'date':
          case 'regexp':
            return 'a ' + type;
          default:
            return type;
        }
      }

      // Returns class name of the object, if any.
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }

      ReactPropTypes.checkPropTypes = checkPropTypes_1;
      ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;

      return ReactPropTypes;
    };

    var propTypes = createCommonjsModule(function (module) {
    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    {
      var ReactIs = reactIs;

      // By explicitly using `prop-types` you are opting into new development behavior.
      // http://fb.me/prop-types-in-prod
      var throwOnDirectAccess = true;
      module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
    }
    });

    var exenv = createCommonjsModule(function (module) {
    /*!
      Copyright (c) 2015 Jed Watson.
      Based on code that is Copyright 2013-2015, Facebook, Inc.
      All rights reserved.
    */
    /* global define */

    (function () {

    	var canUseDOM = !!(
    		typeof window !== 'undefined' &&
    		window.document &&
    		window.document.createElement
    	);

    	var ExecutionEnvironment = {

    		canUseDOM: canUseDOM,

    		canUseWorkers: typeof Worker !== 'undefined',

    		canUseEventListeners:
    			canUseDOM && !!(window.addEventListener || window.attachEvent),

    		canUseViewport: canUseDOM && !!window.screen

    	};

    	if (module.exports) {
    		module.exports = ExecutionEnvironment;
    	} else {
    		window.ExecutionEnvironment = ExecutionEnvironment;
    	}

    }());
    });
    var exenv_1 = exenv.canUseDOM;

    //

    var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

      if (ret !== void 0) {
        return !!ret;
      }

      if (objA === objB) {
        return true;
      }

      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }

      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);

      if (keysA.length !== keysB.length) {
        return false;
      }

      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

      // Test for A's keys different from B.
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];

        if (!bHasOwnProperty(key)) {
          return false;
        }

        var valueA = objA[key];
        var valueB = objB[key];

        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

        if (ret === false || (ret === void 0 && valueA !== valueB)) {
          return false;
        }
      }

      return true;
    };

    function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }


    var React__default = _interopDefault(React__default);
    var ExecutionEnvironment = _interopDefault(exenv);
    var shallowEqual = _interopDefault(shallowequal);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function withSideEffect(reducePropsToState, handleStateChangeOnClient, mapStateOnServer) {
      if (typeof reducePropsToState !== 'function') {
        throw new Error('Expected reducePropsToState to be a function.');
      }
      if (typeof handleStateChangeOnClient !== 'function') {
        throw new Error('Expected handleStateChangeOnClient to be a function.');
      }
      if (typeof mapStateOnServer !== 'undefined' && typeof mapStateOnServer !== 'function') {
        throw new Error('Expected mapStateOnServer to either be undefined or a function.');
      }

      function getDisplayName(WrappedComponent) {
        return WrappedComponent.displayName || WrappedComponent.name || 'Component';
      }

      return function wrap(WrappedComponent) {
        if (typeof WrappedComponent !== 'function') {
          throw new Error('Expected WrappedComponent to be a React component.');
        }

        var mountedInstances = [];
        var state = void 0;

        function emitChange() {
          state = reducePropsToState(mountedInstances.map(function (instance) {
            return instance.props;
          }));

          if (SideEffect.canUseDOM) {
            handleStateChangeOnClient(state);
          } else if (mapStateOnServer) {
            state = mapStateOnServer(state);
          }
        }

        var SideEffect = function (_Component) {
          _inherits(SideEffect, _Component);

          function SideEffect() {
            _classCallCheck(this, SideEffect);

            return _possibleConstructorReturn(this, _Component.apply(this, arguments));
          }

          // Try to use displayName of wrapped component
          SideEffect.peek = function peek() {
            return state;
          };

          // Expose canUseDOM so tests can monkeypatch it


          SideEffect.rewind = function rewind() {
            if (SideEffect.canUseDOM) {
              throw new Error('You may only call rewind() on the server. Call peek() to read the current state.');
            }

            var recordedState = state;
            state = undefined;
            mountedInstances = [];
            return recordedState;
          };

          SideEffect.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
            return !shallowEqual(nextProps, this.props);
          };

          SideEffect.prototype.componentWillMount = function componentWillMount() {
            mountedInstances.push(this);
            emitChange();
          };

          SideEffect.prototype.componentDidUpdate = function componentDidUpdate() {
            emitChange();
          };

          SideEffect.prototype.componentWillUnmount = function componentWillUnmount() {
            var index = mountedInstances.indexOf(this);
            mountedInstances.splice(index, 1);
            emitChange();
          };

          SideEffect.prototype.render = function render() {
            return React__default.createElement(WrappedComponent, this.props);
          };

          return SideEffect;
        }(React__default.Component);

        SideEffect.displayName = 'SideEffect(' + getDisplayName(WrappedComponent) + ')';
        SideEffect.canUseDOM = ExecutionEnvironment.canUseDOM;


        return SideEffect;
      };
    }

    var lib = withSideEffect;

    var keys = createCommonjsModule(function (module, exports) {
    exports = module.exports = typeof Object.keys === 'function'
      ? Object.keys : shim;

    exports.shim = shim;
    function shim (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
    });
    var keys_1 = keys.shim;

    var is_arguments = createCommonjsModule(function (module, exports) {
    var supportsArgumentsClass = (function(){
      return Object.prototype.toString.call(arguments)
    })() == '[object Arguments]';

    exports = module.exports = supportsArgumentsClass ? supported : unsupported;

    exports.supported = supported;
    function supported(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    exports.unsupported = unsupported;
    function unsupported(object){
      return object &&
        typeof object == 'object' &&
        typeof object.length == 'number' &&
        Object.prototype.hasOwnProperty.call(object, 'callee') &&
        !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
        false;
    }});
    var is_arguments_1 = is_arguments.supported;
    var is_arguments_2 = is_arguments.unsupported;

    var deepEqual_1 = createCommonjsModule(function (module) {
    var pSlice = Array.prototype.slice;



    var deepEqual = module.exports = function (actual, expected, opts) {
      if (!opts) opts = {};
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;

      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
        return opts.strict ? actual === expected : actual == expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, opts);
      }
    };

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer (x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') return false;
      return true;
    }

    function objEquiv(a, b, opts) {
      var i, key;
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (is_arguments(a)) {
        if (!is_arguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b, opts);
      }
      if (isBuffer(a)) {
        if (!isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) return false;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      try {
        var ka = keys(a),
            kb = keys(b);
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) return false;
      }
      return typeof a === typeof b;
    }
    });

    var HelmetConstants = createCommonjsModule(function (module, exports) {
    exports.__esModule = true;
    var ATTRIBUTE_NAMES = exports.ATTRIBUTE_NAMES = {
        BODY: "bodyAttributes",
        HTML: "htmlAttributes",
        TITLE: "titleAttributes"
    };

    var TAG_NAMES = exports.TAG_NAMES = {
        BASE: "base",
        BODY: "body",
        HEAD: "head",
        HTML: "html",
        LINK: "link",
        META: "meta",
        NOSCRIPT: "noscript",
        SCRIPT: "script",
        STYLE: "style",
        TITLE: "title"
    };

    var VALID_TAG_NAMES = exports.VALID_TAG_NAMES = Object.keys(TAG_NAMES).map(function (name) {
        return TAG_NAMES[name];
    });

    var TAG_PROPERTIES = exports.TAG_PROPERTIES = {
        CHARSET: "charset",
        CSS_TEXT: "cssText",
        HREF: "href",
        HTTPEQUIV: "http-equiv",
        INNER_HTML: "innerHTML",
        ITEM_PROP: "itemprop",
        NAME: "name",
        PROPERTY: "property",
        REL: "rel",
        SRC: "src"
    };

    var REACT_TAG_MAP = exports.REACT_TAG_MAP = {
        accesskey: "accessKey",
        charset: "charSet",
        class: "className",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        "http-equiv": "httpEquiv",
        itemprop: "itemProp",
        tabindex: "tabIndex"
    };

    var HELMET_PROPS = exports.HELMET_PROPS = {
        DEFAULT_TITLE: "defaultTitle",
        DEFER: "defer",
        ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
        ON_CHANGE_CLIENT_STATE: "onChangeClientState",
        TITLE_TEMPLATE: "titleTemplate"
    };

    var HTML_TAG_MAP = exports.HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function (obj, key) {
        obj[REACT_TAG_MAP[key]] = key;
        return obj;
    }, {});

    var SELF_CLOSING_TAGS = exports.SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];

    var HELMET_ATTRIBUTE = exports.HELMET_ATTRIBUTE = "data-react-helmet";
    });

    unwrapExports(HelmetConstants);
    var HelmetConstants_1 = HelmetConstants.ATTRIBUTE_NAMES;
    var HelmetConstants_2 = HelmetConstants.TAG_NAMES;
    var HelmetConstants_3 = HelmetConstants.VALID_TAG_NAMES;
    var HelmetConstants_4 = HelmetConstants.TAG_PROPERTIES;
    var HelmetConstants_5 = HelmetConstants.REACT_TAG_MAP;
    var HelmetConstants_6 = HelmetConstants.HELMET_PROPS;
    var HelmetConstants_7 = HelmetConstants.HTML_TAG_MAP;
    var HelmetConstants_8 = HelmetConstants.SELF_CLOSING_TAGS;
    var HelmetConstants_9 = HelmetConstants.HELMET_ATTRIBUTE;

    var HelmetUtils = createCommonjsModule(function (module, exports) {
    exports.__esModule = true;
    exports.warn = exports.requestAnimationFrame = exports.reducePropsToState = exports.mapStateOnServer = exports.handleClientStateChange = exports.convertReactPropstoHtmlAttributes = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



    var _react2 = _interopRequireDefault(React__default);



    var _objectAssign2 = _interopRequireDefault(objectAssign);



    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var encodeSpecialCharacters = function encodeSpecialCharacters(str) {
        var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (encode === false) {
            return String(str);
        }

        return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    };

    var getTitleFromPropsList = function getTitleFromPropsList(propsList) {
        var innermostTitle = getInnermostProperty(propsList, HelmetConstants.TAG_NAMES.TITLE);
        var innermostTemplate = getInnermostProperty(propsList, HelmetConstants.HELMET_PROPS.TITLE_TEMPLATE);

        if (innermostTemplate && innermostTitle) {
            // use function arg to avoid need to escape $ characters
            return innermostTemplate.replace(/%s/g, function () {
                return innermostTitle;
            });
        }

        var innermostDefaultTitle = getInnermostProperty(propsList, HelmetConstants.HELMET_PROPS.DEFAULT_TITLE);

        return innermostTitle || innermostDefaultTitle || undefined;
    };

    var getOnChangeClientState = function getOnChangeClientState(propsList) {
        return getInnermostProperty(propsList, HelmetConstants.HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function () {};
    };

    var getAttributesFromPropsList = function getAttributesFromPropsList(tagType, propsList) {
        return propsList.filter(function (props) {
            return typeof props[tagType] !== "undefined";
        }).map(function (props) {
            return props[tagType];
        }).reduce(function (tagAttrs, current) {
            return _extends({}, tagAttrs, current);
        }, {});
    };

    var getBaseTagFromPropsList = function getBaseTagFromPropsList(primaryAttributes, propsList) {
        return propsList.filter(function (props) {
            return typeof props[HelmetConstants.TAG_NAMES.BASE] !== "undefined";
        }).map(function (props) {
            return props[HelmetConstants.TAG_NAMES.BASE];
        }).reverse().reduce(function (innermostBaseTag, tag) {
            if (!innermostBaseTag.length) {
                var keys = Object.keys(tag);

                for (var i = 0; i < keys.length; i++) {
                    var attributeKey = keys[i];
                    var lowerCaseAttributeKey = attributeKey.toLowerCase();

                    if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
                        return innermostBaseTag.concat(tag);
                    }
                }
            }

            return innermostBaseTag;
        }, []);
    };

    var getTagsFromPropsList = function getTagsFromPropsList(tagName, primaryAttributes, propsList) {
        // Calculate list of tags, giving priority innermost component (end of the propslist)
        var approvedSeenTags = {};

        return propsList.filter(function (props) {
            if (Array.isArray(props[tagName])) {
                return true;
            }
            if (typeof props[tagName] !== "undefined") {
                warn("Helmet: " + tagName + " should be of type \"Array\". Instead found type \"" + _typeof(props[tagName]) + "\"");
            }
            return false;
        }).map(function (props) {
            return props[tagName];
        }).reverse().reduce(function (approvedTags, instanceTags) {
            var instanceSeenTags = {};

            instanceTags.filter(function (tag) {
                var primaryAttributeKey = void 0;
                var keys = Object.keys(tag);
                for (var i = 0; i < keys.length; i++) {
                    var attributeKey = keys[i];
                    var lowerCaseAttributeKey = attributeKey.toLowerCase();

                    // Special rule with link tags, since rel and href are both primary tags, rel takes priority
                    if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === HelmetConstants.TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === HelmetConstants.TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
                        primaryAttributeKey = lowerCaseAttributeKey;
                    }
                    // Special case for innerHTML which doesn't work lowercased
                    if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === HelmetConstants.TAG_PROPERTIES.INNER_HTML || attributeKey === HelmetConstants.TAG_PROPERTIES.CSS_TEXT || attributeKey === HelmetConstants.TAG_PROPERTIES.ITEM_PROP)) {
                        primaryAttributeKey = attributeKey;
                    }
                }

                if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
                    return false;
                }

                var value = tag[primaryAttributeKey].toLowerCase();

                if (!approvedSeenTags[primaryAttributeKey]) {
                    approvedSeenTags[primaryAttributeKey] = {};
                }

                if (!instanceSeenTags[primaryAttributeKey]) {
                    instanceSeenTags[primaryAttributeKey] = {};
                }

                if (!approvedSeenTags[primaryAttributeKey][value]) {
                    instanceSeenTags[primaryAttributeKey][value] = true;
                    return true;
                }

                return false;
            }).reverse().forEach(function (tag) {
                return approvedTags.push(tag);
            });

            // Update seen tags with tags from this instance
            var keys = Object.keys(instanceSeenTags);
            for (var i = 0; i < keys.length; i++) {
                var attributeKey = keys[i];
                var tagUnion = (0, _objectAssign2.default)({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);

                approvedSeenTags[attributeKey] = tagUnion;
            }

            return approvedTags;
        }, []).reverse();
    };

    var getInnermostProperty = function getInnermostProperty(propsList, property) {
        for (var i = propsList.length - 1; i >= 0; i--) {
            var props = propsList[i];

            if (props.hasOwnProperty(property)) {
                return props[property];
            }
        }

        return null;
    };

    var reducePropsToState = function reducePropsToState(propsList) {
        return {
            baseTag: getBaseTagFromPropsList([HelmetConstants.TAG_PROPERTIES.HREF], propsList),
            bodyAttributes: getAttributesFromPropsList(HelmetConstants.ATTRIBUTE_NAMES.BODY, propsList),
            defer: getInnermostProperty(propsList, HelmetConstants.HELMET_PROPS.DEFER),
            encode: getInnermostProperty(propsList, HelmetConstants.HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
            htmlAttributes: getAttributesFromPropsList(HelmetConstants.ATTRIBUTE_NAMES.HTML, propsList),
            linkTags: getTagsFromPropsList(HelmetConstants.TAG_NAMES.LINK, [HelmetConstants.TAG_PROPERTIES.REL, HelmetConstants.TAG_PROPERTIES.HREF], propsList),
            metaTags: getTagsFromPropsList(HelmetConstants.TAG_NAMES.META, [HelmetConstants.TAG_PROPERTIES.NAME, HelmetConstants.TAG_PROPERTIES.CHARSET, HelmetConstants.TAG_PROPERTIES.HTTPEQUIV, HelmetConstants.TAG_PROPERTIES.PROPERTY, HelmetConstants.TAG_PROPERTIES.ITEM_PROP], propsList),
            noscriptTags: getTagsFromPropsList(HelmetConstants.TAG_NAMES.NOSCRIPT, [HelmetConstants.TAG_PROPERTIES.INNER_HTML], propsList),
            onChangeClientState: getOnChangeClientState(propsList),
            scriptTags: getTagsFromPropsList(HelmetConstants.TAG_NAMES.SCRIPT, [HelmetConstants.TAG_PROPERTIES.SRC, HelmetConstants.TAG_PROPERTIES.INNER_HTML], propsList),
            styleTags: getTagsFromPropsList(HelmetConstants.TAG_NAMES.STYLE, [HelmetConstants.TAG_PROPERTIES.CSS_TEXT], propsList),
            title: getTitleFromPropsList(propsList),
            titleAttributes: getAttributesFromPropsList(HelmetConstants.ATTRIBUTE_NAMES.TITLE, propsList)
        };
    };

    var rafPolyfill = function () {
        var clock = Date.now();

        return function (callback) {
            var currentTime = Date.now();

            if (currentTime - clock > 16) {
                clock = currentTime;
                callback(currentTime);
            } else {
                setTimeout(function () {
                    rafPolyfill(callback);
                }, 0);
            }
        };
    }();

    var cafPolyfill = function cafPolyfill(id) {
        return clearTimeout(id);
    };

    var requestAnimationFrame = typeof window !== "undefined" ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : commonjsGlobal.requestAnimationFrame || rafPolyfill;

    var cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : commonjsGlobal.cancelAnimationFrame || cafPolyfill;

    var warn = function warn(msg) {
        return console && typeof console.warn === "function" && console.warn(msg);
    };

    var _helmetCallback = null;

    var handleClientStateChange = function handleClientStateChange(newState) {
        if (_helmetCallback) {
            cancelAnimationFrame(_helmetCallback);
        }

        if (newState.defer) {
            _helmetCallback = requestAnimationFrame(function () {
                commitTagChanges(newState, function () {
                    _helmetCallback = null;
                });
            });
        } else {
            commitTagChanges(newState);
            _helmetCallback = null;
        }
    };

    var commitTagChanges = function commitTagChanges(newState, cb) {
        var baseTag = newState.baseTag,
            bodyAttributes = newState.bodyAttributes,
            htmlAttributes = newState.htmlAttributes,
            linkTags = newState.linkTags,
            metaTags = newState.metaTags,
            noscriptTags = newState.noscriptTags,
            onChangeClientState = newState.onChangeClientState,
            scriptTags = newState.scriptTags,
            styleTags = newState.styleTags,
            title = newState.title,
            titleAttributes = newState.titleAttributes;

        updateAttributes(HelmetConstants.TAG_NAMES.BODY, bodyAttributes);
        updateAttributes(HelmetConstants.TAG_NAMES.HTML, htmlAttributes);

        updateTitle(title, titleAttributes);

        var tagUpdates = {
            baseTag: updateTags(HelmetConstants.TAG_NAMES.BASE, baseTag),
            linkTags: updateTags(HelmetConstants.TAG_NAMES.LINK, linkTags),
            metaTags: updateTags(HelmetConstants.TAG_NAMES.META, metaTags),
            noscriptTags: updateTags(HelmetConstants.TAG_NAMES.NOSCRIPT, noscriptTags),
            scriptTags: updateTags(HelmetConstants.TAG_NAMES.SCRIPT, scriptTags),
            styleTags: updateTags(HelmetConstants.TAG_NAMES.STYLE, styleTags)
        };

        var addedTags = {};
        var removedTags = {};

        Object.keys(tagUpdates).forEach(function (tagType) {
            var _tagUpdates$tagType = tagUpdates[tagType],
                newTags = _tagUpdates$tagType.newTags,
                oldTags = _tagUpdates$tagType.oldTags;


            if (newTags.length) {
                addedTags[tagType] = newTags;
            }
            if (oldTags.length) {
                removedTags[tagType] = tagUpdates[tagType].oldTags;
            }
        });

        cb && cb();

        onChangeClientState(newState, addedTags, removedTags);
    };

    var flattenArray = function flattenArray(possibleArray) {
        return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
    };

    var updateTitle = function updateTitle(title, attributes) {
        if (typeof title !== "undefined" && document.title !== title) {
            document.title = flattenArray(title);
        }

        updateAttributes(HelmetConstants.TAG_NAMES.TITLE, attributes);
    };

    var updateAttributes = function updateAttributes(tagName, attributes) {
        var elementTag = document.getElementsByTagName(tagName)[0];

        if (!elementTag) {
            return;
        }

        var helmetAttributeString = elementTag.getAttribute(HelmetConstants.HELMET_ATTRIBUTE);
        var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
        var attributesToRemove = [].concat(helmetAttributes);
        var attributeKeys = Object.keys(attributes);

        for (var i = 0; i < attributeKeys.length; i++) {
            var attribute = attributeKeys[i];
            var value = attributes[attribute] || "";

            if (elementTag.getAttribute(attribute) !== value) {
                elementTag.setAttribute(attribute, value);
            }

            if (helmetAttributes.indexOf(attribute) === -1) {
                helmetAttributes.push(attribute);
            }

            var indexToSave = attributesToRemove.indexOf(attribute);
            if (indexToSave !== -1) {
                attributesToRemove.splice(indexToSave, 1);
            }
        }

        for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
            elementTag.removeAttribute(attributesToRemove[_i]);
        }

        if (helmetAttributes.length === attributesToRemove.length) {
            elementTag.removeAttribute(HelmetConstants.HELMET_ATTRIBUTE);
        } else if (elementTag.getAttribute(HelmetConstants.HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
            elementTag.setAttribute(HelmetConstants.HELMET_ATTRIBUTE, attributeKeys.join(","));
        }
    };

    var updateTags = function updateTags(type, tags) {
        var headElement = document.head || document.querySelector(HelmetConstants.TAG_NAMES.HEAD);
        var tagNodes = headElement.querySelectorAll(type + "[" + HelmetConstants.HELMET_ATTRIBUTE + "]");
        var oldTags = Array.prototype.slice.call(tagNodes);
        var newTags = [];
        var indexToDelete = void 0;

        if (tags && tags.length) {
            tags.forEach(function (tag) {
                var newElement = document.createElement(type);

                for (var attribute in tag) {
                    if (tag.hasOwnProperty(attribute)) {
                        if (attribute === HelmetConstants.TAG_PROPERTIES.INNER_HTML) {
                            newElement.innerHTML = tag.innerHTML;
                        } else if (attribute === HelmetConstants.TAG_PROPERTIES.CSS_TEXT) {
                            if (newElement.styleSheet) {
                                newElement.styleSheet.cssText = tag.cssText;
                            } else {
                                newElement.appendChild(document.createTextNode(tag.cssText));
                            }
                        } else {
                            var value = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
                            newElement.setAttribute(attribute, value);
                        }
                    }
                }

                newElement.setAttribute(HelmetConstants.HELMET_ATTRIBUTE, "true");

                // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.
                if (oldTags.some(function (existingTag, index) {
                    indexToDelete = index;
                    return newElement.isEqualNode(existingTag);
                })) {
                    oldTags.splice(indexToDelete, 1);
                } else {
                    newTags.push(newElement);
                }
            });
        }

        oldTags.forEach(function (tag) {
            return tag.parentNode.removeChild(tag);
        });
        newTags.forEach(function (tag) {
            return headElement.appendChild(tag);
        });

        return {
            oldTags: oldTags,
            newTags: newTags
        };
    };

    var generateElementAttributesAsString = function generateElementAttributesAsString(attributes) {
        return Object.keys(attributes).reduce(function (str, key) {
            var attr = typeof attributes[key] !== "undefined" ? key + "=\"" + attributes[key] + "\"" : "" + key;
            return str ? str + " " + attr : attr;
        }, "");
    };

    var generateTitleAsString = function generateTitleAsString(type, title, attributes, encode) {
        var attributeString = generateElementAttributesAsString(attributes);
        var flattenedTitle = flattenArray(title);
        return attributeString ? "<" + type + " " + HelmetConstants.HELMET_ATTRIBUTE + "=\"true\" " + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">" : "<" + type + " " + HelmetConstants.HELMET_ATTRIBUTE + "=\"true\">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">";
    };

    var generateTagsAsString = function generateTagsAsString(type, tags, encode) {
        return tags.reduce(function (str, tag) {
            var attributeHtml = Object.keys(tag).filter(function (attribute) {
                return !(attribute === HelmetConstants.TAG_PROPERTIES.INNER_HTML || attribute === HelmetConstants.TAG_PROPERTIES.CSS_TEXT);
            }).reduce(function (string, attribute) {
                var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + "=\"" + encodeSpecialCharacters(tag[attribute], encode) + "\"";
                return string ? string + " " + attr : attr;
            }, "");

            var tagContent = tag.innerHTML || tag.cssText || "";

            var isSelfClosing = HelmetConstants.SELF_CLOSING_TAGS.indexOf(type) === -1;

            return str + "<" + type + " " + HelmetConstants.HELMET_ATTRIBUTE + "=\"true\" " + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type + ">");
        }, "");
    };

    var convertElementAttributestoReactProps = function convertElementAttributestoReactProps(attributes) {
        var initProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return Object.keys(attributes).reduce(function (obj, key) {
            obj[HelmetConstants.REACT_TAG_MAP[key] || key] = attributes[key];
            return obj;
        }, initProps);
    };

    var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes(props) {
        var initAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return Object.keys(props).reduce(function (obj, key) {
            obj[HelmetConstants.HTML_TAG_MAP[key] || key] = props[key];
            return obj;
        }, initAttributes);
    };

    var generateTitleAsReactComponent = function generateTitleAsReactComponent(type, title, attributes) {
        var _initProps;

        // assigning into an array to define toString function on it
        var initProps = (_initProps = {
            key: title
        }, _initProps[HelmetConstants.HELMET_ATTRIBUTE] = true, _initProps);
        var props = convertElementAttributestoReactProps(attributes, initProps);

        return [_react2.default.createElement(HelmetConstants.TAG_NAMES.TITLE, props, title)];
    };

    var generateTagsAsReactComponent = function generateTagsAsReactComponent(type, tags) {
        return tags.map(function (tag, i) {
            var _mappedTag;

            var mappedTag = (_mappedTag = {
                key: i
            }, _mappedTag[HelmetConstants.HELMET_ATTRIBUTE] = true, _mappedTag);

            Object.keys(tag).forEach(function (attribute) {
                var mappedAttribute = HelmetConstants.REACT_TAG_MAP[attribute] || attribute;

                if (mappedAttribute === HelmetConstants.TAG_PROPERTIES.INNER_HTML || mappedAttribute === HelmetConstants.TAG_PROPERTIES.CSS_TEXT) {
                    var content = tag.innerHTML || tag.cssText;
                    mappedTag.dangerouslySetInnerHTML = { __html: content };
                } else {
                    mappedTag[mappedAttribute] = tag[attribute];
                }
            });

            return _react2.default.createElement(type, mappedTag);
        });
    };

    var getMethodsForTag = function getMethodsForTag(type, tags, encode) {
        switch (type) {
            case HelmetConstants.TAG_NAMES.TITLE:
                return {
                    toComponent: function toComponent() {
                        return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, encode);
                    },
                    toString: function toString() {
                        return generateTitleAsString(type, tags.title, tags.titleAttributes, encode);
                    }
                };
            case HelmetConstants.ATTRIBUTE_NAMES.BODY:
            case HelmetConstants.ATTRIBUTE_NAMES.HTML:
                return {
                    toComponent: function toComponent() {
                        return convertElementAttributestoReactProps(tags);
                    },
                    toString: function toString() {
                        return generateElementAttributesAsString(tags);
                    }
                };
            default:
                return {
                    toComponent: function toComponent() {
                        return generateTagsAsReactComponent(type, tags);
                    },
                    toString: function toString() {
                        return generateTagsAsString(type, tags, encode);
                    }
                };
        }
    };

    var mapStateOnServer = function mapStateOnServer(_ref) {
        var baseTag = _ref.baseTag,
            bodyAttributes = _ref.bodyAttributes,
            encode = _ref.encode,
            htmlAttributes = _ref.htmlAttributes,
            linkTags = _ref.linkTags,
            metaTags = _ref.metaTags,
            noscriptTags = _ref.noscriptTags,
            scriptTags = _ref.scriptTags,
            styleTags = _ref.styleTags,
            _ref$title = _ref.title,
            title = _ref$title === undefined ? "" : _ref$title,
            titleAttributes = _ref.titleAttributes;
        return {
            base: getMethodsForTag(HelmetConstants.TAG_NAMES.BASE, baseTag, encode),
            bodyAttributes: getMethodsForTag(HelmetConstants.ATTRIBUTE_NAMES.BODY, bodyAttributes, encode),
            htmlAttributes: getMethodsForTag(HelmetConstants.ATTRIBUTE_NAMES.HTML, htmlAttributes, encode),
            link: getMethodsForTag(HelmetConstants.TAG_NAMES.LINK, linkTags, encode),
            meta: getMethodsForTag(HelmetConstants.TAG_NAMES.META, metaTags, encode),
            noscript: getMethodsForTag(HelmetConstants.TAG_NAMES.NOSCRIPT, noscriptTags, encode),
            script: getMethodsForTag(HelmetConstants.TAG_NAMES.SCRIPT, scriptTags, encode),
            style: getMethodsForTag(HelmetConstants.TAG_NAMES.STYLE, styleTags, encode),
            title: getMethodsForTag(HelmetConstants.TAG_NAMES.TITLE, { title: title, titleAttributes: titleAttributes }, encode)
        };
    };

    exports.convertReactPropstoHtmlAttributes = convertReactPropstoHtmlAttributes;
    exports.handleClientStateChange = handleClientStateChange;
    exports.mapStateOnServer = mapStateOnServer;
    exports.reducePropsToState = reducePropsToState;
    exports.requestAnimationFrame = requestAnimationFrame;
    exports.warn = warn;
    });

    unwrapExports(HelmetUtils);
    var HelmetUtils_1 = HelmetUtils.warn;
    var HelmetUtils_2 = HelmetUtils.requestAnimationFrame;
    var HelmetUtils_3 = HelmetUtils.reducePropsToState;
    var HelmetUtils_4 = HelmetUtils.mapStateOnServer;
    var HelmetUtils_5 = HelmetUtils.handleClientStateChange;
    var HelmetUtils_6 = HelmetUtils.convertReactPropstoHtmlAttributes;

    var Helmet_1 = createCommonjsModule(function (module, exports) {
    exports.__esModule = true;
    exports.Helmet = undefined;

    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _react2 = _interopRequireDefault(React__default);



    var _propTypes2 = _interopRequireDefault(propTypes);



    var _reactSideEffect2 = _interopRequireDefault(lib);



    var _deepEqual2 = _interopRequireDefault(deepEqual_1);





    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Helmet = function Helmet(Component) {
        var _class, _temp;

        return _temp = _class = function (_React$Component) {
            _inherits(HelmetWrapper, _React$Component);

            function HelmetWrapper() {
                _classCallCheck(this, HelmetWrapper);

                return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }

            HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
                return !(0, _deepEqual2.default)(this.props, nextProps);
            };

            HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
                if (!nestedChildren) {
                    return null;
                }

                switch (child.type) {
                    case HelmetConstants.TAG_NAMES.SCRIPT:
                    case HelmetConstants.TAG_NAMES.NOSCRIPT:
                        return {
                            innerHTML: nestedChildren
                        };

                    case HelmetConstants.TAG_NAMES.STYLE:
                        return {
                            cssText: nestedChildren
                        };
                }

                throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
            };

            HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
                var _extends2;

                var child = _ref.child,
                    arrayTypeChildren = _ref.arrayTypeChildren,
                    newChildProps = _ref.newChildProps,
                    nestedChildren = _ref.nestedChildren;

                return _extends({}, arrayTypeChildren, (_extends2 = {}, _extends2[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _extends2));
            };

            HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
                var _extends3, _extends4;

                var child = _ref2.child,
                    newProps = _ref2.newProps,
                    newChildProps = _ref2.newChildProps,
                    nestedChildren = _ref2.nestedChildren;

                switch (child.type) {
                    case HelmetConstants.TAG_NAMES.TITLE:
                        return _extends({}, newProps, (_extends3 = {}, _extends3[child.type] = nestedChildren, _extends3.titleAttributes = _extends({}, newChildProps), _extends3));

                    case HelmetConstants.TAG_NAMES.BODY:
                        return _extends({}, newProps, {
                            bodyAttributes: _extends({}, newChildProps)
                        });

                    case HelmetConstants.TAG_NAMES.HTML:
                        return _extends({}, newProps, {
                            htmlAttributes: _extends({}, newChildProps)
                        });
                }

                return _extends({}, newProps, (_extends4 = {}, _extends4[child.type] = _extends({}, newChildProps), _extends4));
            };

            HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
                var newFlattenedProps = _extends({}, newProps);

                Object.keys(arrayTypeChildren).forEach(function (arrayChildName) {
                    var _extends5;

                    newFlattenedProps = _extends({}, newFlattenedProps, (_extends5 = {}, _extends5[arrayChildName] = arrayTypeChildren[arrayChildName], _extends5));
                });

                return newFlattenedProps;
            };

            HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
                {
                    if (!HelmetConstants.VALID_TAG_NAMES.some(function (name) {
                        return child.type === name;
                    })) {
                        if (typeof child.type === "function") {
                            return (0, HelmetUtils.warn)("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.");
                        }

                        return (0, HelmetUtils.warn)("Only elements types " + HelmetConstants.VALID_TAG_NAMES.join(", ") + " are allowed. Helmet does not support rendering <" + child.type + "> elements. Refer to our API for more information.");
                    }

                    if (nestedChildren && typeof nestedChildren !== "string" && (!Array.isArray(nestedChildren) || nestedChildren.some(function (nestedChild) {
                        return typeof nestedChild !== "string";
                    }))) {
                        throw new Error("Helmet expects a string as a child of <" + child.type + ">. Did you forget to wrap your children in braces? ( <" + child.type + ">{``}</" + child.type + "> ) Refer to our API for more information.");
                    }
                }

                return true;
            };

            HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
                var _this2 = this;

                var arrayTypeChildren = {};

                _react2.default.Children.forEach(children, function (child) {
                    if (!child || !child.props) {
                        return;
                    }

                    var _child$props = child.props,
                        nestedChildren = _child$props.children,
                        childProps = _objectWithoutProperties(_child$props, ["children"]);

                    var newChildProps = (0, HelmetUtils.convertReactPropstoHtmlAttributes)(childProps);

                    _this2.warnOnInvalidChildren(child, nestedChildren);

                    switch (child.type) {
                        case HelmetConstants.TAG_NAMES.LINK:
                        case HelmetConstants.TAG_NAMES.META:
                        case HelmetConstants.TAG_NAMES.NOSCRIPT:
                        case HelmetConstants.TAG_NAMES.SCRIPT:
                        case HelmetConstants.TAG_NAMES.STYLE:
                            arrayTypeChildren = _this2.flattenArrayTypeChildren({
                                child: child,
                                arrayTypeChildren: arrayTypeChildren,
                                newChildProps: newChildProps,
                                nestedChildren: nestedChildren
                            });
                            break;

                        default:
                            newProps = _this2.mapObjectTypeChildren({
                                child: child,
                                newProps: newProps,
                                newChildProps: newChildProps,
                                nestedChildren: nestedChildren
                            });
                            break;
                    }
                });

                newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
                return newProps;
            };

            HelmetWrapper.prototype.render = function render() {
                var _props = this.props,
                    children = _props.children,
                    props = _objectWithoutProperties(_props, ["children"]);

                var newProps = _extends({}, props);

                if (children) {
                    newProps = this.mapChildrenToProps(children, newProps);
                }

                return _react2.default.createElement(Component, newProps);
            };

            _createClass(HelmetWrapper, null, [{
                key: "canUseDOM",


                // Component.peek comes from react-side-effect:
                // For testing, you may use a static peek() method available on the returned component.
                // It lets you get the current state without resetting the mounted instance stack.
                // Dont use it for anything other than testing.

                /**
                * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
                * @param {Object} bodyAttributes: {"className": "root"}
                * @param {String} defaultTitle: "Default Title"
                * @param {Boolean} defer: true
                * @param {Boolean} encodeSpecialCharacters: true
                * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
                * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
                * @param {Array} meta: [{"name": "description", "content": "Test description"}]
                * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
                * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
                * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
                * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
                * @param {String} title: "Title"
                * @param {Object} titleAttributes: {"itemprop": "name"}
                * @param {String} titleTemplate: "MySite.com - %s"
                */
                set: function set(canUseDOM) {
                    Component.canUseDOM = canUseDOM;
                }
            }]);

            return HelmetWrapper;
        }(_react2.default.Component), _class.propTypes = {
            base: _propTypes2.default.object,
            bodyAttributes: _propTypes2.default.object,
            children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),
            defaultTitle: _propTypes2.default.string,
            defer: _propTypes2.default.bool,
            encodeSpecialCharacters: _propTypes2.default.bool,
            htmlAttributes: _propTypes2.default.object,
            link: _propTypes2.default.arrayOf(_propTypes2.default.object),
            meta: _propTypes2.default.arrayOf(_propTypes2.default.object),
            noscript: _propTypes2.default.arrayOf(_propTypes2.default.object),
            onChangeClientState: _propTypes2.default.func,
            script: _propTypes2.default.arrayOf(_propTypes2.default.object),
            style: _propTypes2.default.arrayOf(_propTypes2.default.object),
            title: _propTypes2.default.string,
            titleAttributes: _propTypes2.default.object,
            titleTemplate: _propTypes2.default.string
        }, _class.defaultProps = {
            defer: true,
            encodeSpecialCharacters: true
        }, _class.peek = Component.peek, _class.rewind = function () {
            var mappedState = Component.rewind();
            if (!mappedState) {
                // provide fallback if mappedState is undefined
                mappedState = (0, HelmetUtils.mapStateOnServer)({
                    baseTag: [],
                    bodyAttributes: {},
                    encodeSpecialCharacters: true,
                    htmlAttributes: {},
                    linkTags: [],
                    metaTags: [],
                    noscriptTags: [],
                    scriptTags: [],
                    styleTags: [],
                    title: "",
                    titleAttributes: {}
                });
            }

            return mappedState;
        }, _temp;
    };

    var NullComponent = function NullComponent() {
        return null;
    };

    var HelmetSideEffects = (0, _reactSideEffect2.default)(HelmetUtils.reducePropsToState, HelmetUtils.handleClientStateChange, HelmetUtils.mapStateOnServer)(NullComponent);

    var HelmetExport = Helmet(HelmetSideEffects);
    HelmetExport.renderStatic = HelmetExport.rewind;

    exports.Helmet = HelmetExport;
    exports.default = HelmetExport;
    });

    unwrapExports(Helmet_1);
    var Helmet_2 = Helmet_1.Helmet;

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$2 = (undefined && undefined.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    var View = function View(props) {
        return (React.createElement(NaviContext.Consumer, null, function (context) { return React.createElement(InnerView, __assign$2({}, props, { context: context })); }));
    };
    View.defaultProps = {
        hashScrollBehavior: 'smooth',
        where: function (Chunk) { return Chunk.type === 'view'; }
    };
    // Memoize these to stop a bizarre react-helmet infinite loop bug when titles
    // are recreated on each render
    var titles = {};
    function createTitleElement(str) {
        var title = titles[str];
        if (!title) {
            title = titles[str] = React.createElement("title", null, str);
        }
        return title;
    }
    var InnerView = /** @class */ (function (_super) {
        __extends$3(InnerView, _super);
        function InnerView(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {};
            return _this;
        }
        InnerView.getDerivedStateFromProps = function (props, state) {
            var route = props.context.steadyRoute || props.context.busyRoute;
            // If there's no steady route, then we'll need to wait until a steady
            // route becomes available.
            if (!route) {
                return null;
            }
            // Bail if nothing has changed
            if (state.route === route &&
                state.childContext && state.childContext.busyRoute === props.context.busyRoute) {
                return null;
            }
            var unconsumedChunks = props.context.unconsumedSteadyRouteChunks ||
                route.chunks;
            var index = unconsumedChunks.findIndex(props.where);
            var errorSearchChunks = index === -1 ? unconsumedChunks : unconsumedChunks.slice(0, index + 1);
            var errorChunk = errorSearchChunks.find(function (Chunk) { return Chunk.type === 'error'; });
            if (errorChunk) {
                return {
                    error: errorChunk.error || new Error("Unknown routing error")
                };
            }
            if (index === -1) {
                return null;
            }
            var Chunk = unconsumedChunks[index];
            // Find any unconsumed head content that comes before and after this
            // Chunk.
            var headAndTitleChunks = unconsumedChunks
                .slice(0, index)
                .filter(function (Chunk) { return Chunk.type === 'title' || Chunk.type === 'head'; });
            for (index += 1; index < unconsumedChunks.length; index++) {
                var Chunk_1 = unconsumedChunks[index];
                if (Chunk_1.type === 'busy' || Chunk_1.type === 'error' || props.where(Chunk_1)) {
                    break;
                }
                if (Chunk_1.type === 'title' || Chunk_1.type === 'head') {
                    headAndTitleChunks.push(Chunk_1);
                }
            }
            return {
                Chunk: Chunk,
                headAndTitleChunks: headAndTitleChunks,
                route: route,
                childContext: __assign$2({}, props.context, { busyRoute: props.context.busyRoute, unconsumedSteadyRouteChunks: unconsumedChunks.slice(index) }),
            };
        };
        InnerView.prototype.componentDidUpdate = function (prevProps, prevState) {
            this.handleUpdate(prevState);
        };
        InnerView.prototype.componentDidMount = function () {
            this.handleUpdate();
        };
        InnerView.prototype.handleUpdate = function (prevState) {
            if (this.state.route && (!prevState || !prevState.route || prevState.route !== this.state.route)) {
                var prevRoute = prevState && prevState.route;
                var nextRoute = this.state.route;
                if (nextRoute && nextRoute.type !== 'busy') {
                    if (prevRoute &&
                        nextRoute.url.pathname === prevRoute.url.pathname &&
                        nextRoute.url.search === prevRoute.url.search &&
                        nextRoute.url.hash === prevRoute.url.hash) {
                        return;
                    }
                    if (!this.props.disableScrolling &&
                        (!prevRoute ||
                            !prevRoute.url ||
                            prevRoute.url.hash !== nextRoute.url.hash ||
                            prevRoute.url.pathname !== nextRoute.url.pathname)) {
                        scrollToHash(nextRoute.url.hash, prevRoute && prevRoute.url && prevRoute.url.pathname === nextRoute.url.pathname
                            ? this.props.hashScrollBehavior
                            : 'auto');
                    }
                }
            }
        };
        InnerView.prototype.render = function () {
            if (this.state.error) {
                throw this.state.error;
            }
            var _a = this.state, Chunk = _a.Chunk, headAndTitleChunks = _a.headAndTitleChunks;
            if (!Chunk || !Chunk.view) {
                var Suspense = React.Suspense;
                if (Suspense) {
                    throw this.props.context.navigation.getRoute();
                }
                else {
                    console.warn("A Navi <View> component was rendered before your Navigation store's state had become steady. Consider waiting before rendering with \"await navigation.getRoute()\", or upgrading React to version 16.6 to handle this with Suspense.");
                    return null;
                }
            }
            var helmet = headAndTitleChunks &&
                headAndTitleChunks.length && React.createElement.apply(React, [Helmet_2,
                null].concat(headAndTitleChunks.map(function (Chunk) {
                return Chunk.type === 'title' ? (createTitleElement(Chunk.title)) : ((Chunk.head.type === React.Fragment || Chunk.head.type === 'head')
                    ? Chunk.head.props.children
                    : Chunk.head);
            })));
            var content;
            var render;
            if (this.props.children) {
                render = this.props.children;
                if (typeof render !== "function") {
                    throw new Error("A Navi <View> expects any children to be a function, but instead received \"" + render + "\".");
                }
                content = this.props.children(Chunk.view, this.state.route);
            }
            else if (Chunk.view) {
                if (typeof Chunk.view === 'function') {
                    content = React.createElement(Chunk.view, { route: this.props.context.steadyRoute });
                }
                else if (typeof Chunk.view === 'string' || React.isValidElement(Chunk.view)) {
                    content = Chunk.view;
                }
            }
            else {
                throw new Error("A Navi <View> was not able to find a `children` prop, and was unable to find any body or head content in the consumed Route Chunk's `content`.");
            }
            return (React.createElement(NaviContext.Provider, { value: this.state.childContext },
                helmet || null,
                // Clone the content to force a re-render even if content hasn't
                // changed, as Provider is a PureComponent.
                React.isValidElement(content)
                    ? React.cloneElement(content)
                    : content));
        };
        return InnerView;
    }(React.Component));
    var MissingChunk = /** @class */ (function (_super) {
        __extends$3(MissingChunk, _super);
        function MissingChunk(context) {
            var _this = _super.call(this, "A Navi <View> component attempted to use a Chunk that couldn't be found. This is likely due to its \"where\" prop.") || this;
            _this.context = context;
            return _this;
        }
        return MissingChunk;
    }(navi.NaviError));

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Router = /** @class */ (function (_super) {
        __extends$4(Router, _super);
        function Router(props) {
            var _this = _super.call(this, props) || this;
            if (props.navigation) {
                if (props.basename) {
                    console.warn("Warning: <Router> can't receive both a \"basename\" and a \"navigation\" prop. Proceeding by ignoring \"basename\".");
                }
                if (props.routes) {
                    console.warn("Warning: <Router> can't receive both a \"routes\" and a \"navigation\" prop. Proceeding by ignoring \"routes\".");
                }
                if (props.history) {
                    console.warn("Warning: <Router> can't receive both a \"history\" and a \"navigation\" prop. Proceeding by ignoring \"history\".");
                }
            }
            _this.navigation = props.navigation || navi.createBrowserNavigation({
                basename: props.basename,
                context: props.context,
                history: props.history,
                routes: props.routes,
            });
            return _this;
        }
        Router.prototype.render = function () {
            var children = this.props.children;
            return (React.createElement(NaviProvider, { navigation: this.navigation }, children || React.createElement(View, null)));
        };
        Router.prototype.componentDidMount = function () {
            if (this.props.navigation && this.props.context) {
                this.props.navigation.setContext(this.props.context);
            }
        };
        Router.prototype.componentDidUpdate = function (prevProps) {
            if (shallowDiffers(prevProps.context || {}, this.props.context || {})) {
                this.navigation.setContext(this.props.context || {});
            }
        };
        Router.prototype.componentWillUnmount = function () {
            // Clean up any navigation object that we've created.
            if (!this.props.navigation) {
                this.navigation.dispose();
            }
            delete this.navigation;
        };
        Router.defaultProps = {
            fallback: undefined,
        };
        return Router;
    }(React.Component));
    // Pulled from react-compat
    // https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349
    function shallowDiffers(a, b) {
        for (var i in a)
            if (!(i in b))
                return true;
        for (var i in b)
            if (a[i] !== b[i])
                return true;
        return false;
    }

    function useNavigation() {
        return React.useContext(NaviContext).navigation;
    }
    function NaviConsumer(_a) {
        var children = _a.children;
        return (React.createElement(NaviContext.Consumer, { children: function (_a) {
                var navigation = _a.navigation;
                return children(navigation);
            } }));
    }

    function useHistory() {
        return React.useContext(NaviContext).navigation.history;
    }
    function History(props) {
        return (React.createElement(NaviContext.Consumer, null, function (context) { return props.children(context.navigation.history); }));
    }

    function useLoadingRoute() {
        return React.useContext(NaviContext).busyRoute;
    }
    // This is a PureComponent so that setting state to loading
    // when it is already loading won't cause a re-render
    function LoadingRoute(props) {
        return (React.createElement(NaviContext.Consumer, null, function (context) { return props.children(context.busyRoute); }));
    }

    function useCurrentRoute() {
        var _a = React.useContext(NaviContext), steadyRoute = _a.steadyRoute, busyRoute = _a.busyRoute;
        return (steadyRoute || busyRoute);
    }
    function CurrentRoute(props) {
        return (React.createElement(NaviContext.Consumer, null, function (context) { return props.children((context.steadyRoute || context.busyRoute)); }));
    }

    exports.Link = Link;
    exports.NavLink = Link;
    exports.NaviProvider = NaviProvider;
    exports.NavProvider = NaviProvider;
    exports.NotFoundBoundary = NotFoundBoundary;
    exports.NavNotFoundBoundary = NotFoundBoundary;
    exports.Router = Router;
    exports.useNavigation = useNavigation;
    exports.NaviConsumer = NaviConsumer;
    exports.useHistory = useHistory;
    exports.History = History;
    exports.NavHistory = History;
    exports.useLoadingRoute = useLoadingRoute;
    exports.LoadingRoute = LoadingRoute;
    exports.NavLoading = LoadingRoute;
    exports.useCurrentRoute = useCurrentRoute;
    exports.CurrentRoute = CurrentRoute;
    exports.NavRoute = CurrentRoute;
    exports.View = View;
    exports.NavContent = View;
    exports.NavContextProvider = NavContextProvider;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
