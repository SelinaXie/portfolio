{"ast":null,"code":"import _toConsumableArray from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _asyncToGenerator from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nvar _jsxFileName = \"/Users/selinaxie/Documents/AppLab/ss/portfolio/src/routes/tags.js\";\nimport React from 'react';\nimport { compose, crawl, mount, resolve, route, withContext, withCrawlerPatterns } from 'navi';\nimport { join } from 'path';\nimport { fromPairs } from 'lodash';\nimport TagIndexPage from '../components/TagIndexPage';\nimport TagPage from '../components/TagPage';\nimport routes from './index';\n\nfunction crawlRoutes(_x) {\n  return _crawlRoutes.apply(this, arguments);\n}\n\nfunction _crawlRoutes() {\n  _crawlRoutes = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(root) {\n    var _ref2, paths;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (crawlRoutes.cache[root]) {\n              _context4.next = 8;\n              break;\n            }\n\n            _context4.next = 3;\n            return crawl({\n              context: {\n                crawlingRoutes: true\n              },\n              root: root,\n              routes: routes\n            });\n\n          case 3:\n            _ref2 = _context4.sent;\n            paths = _ref2.paths;\n            _context4.next = 7;\n            return resolve({\n              method: 'HEAD',\n              routes: routes,\n              urls: paths\n            });\n\n          case 7:\n            crawlRoutes.cache[root] = _context4.sent;\n\n          case 8:\n            return _context4.abrupt(\"return\", crawlRoutes.cache[root]);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _crawlRoutes.apply(this, arguments);\n}\n\ncrawlRoutes.cache = {};\nvar tagRoutes = compose(withContext(function (req, context) {\n  return _objectSpread({}, context, {\n    tagsRoot: req.mountpath\n  });\n}), withCrawlerPatterns({\n  '/:tag': function () {\n    var _tag = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(req, context) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (context.crawlingRoutes) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.t0 = getAvailableTagsFromRoutes;\n              _context.next = 4;\n              return crawlRoutes(context.blogRoot);\n\n            case 4:\n              _context.t1 = _context.sent;\n\n              _context.t2 = function (tag) {\n                return '/' + tag;\n              };\n\n              return _context.abrupt(\"return\", (0, _context.t0)(_context.t1).map(_context.t2));\n\n            case 7:\n              return _context.abrupt(\"return\", []);\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function tag(_x2, _x3) {\n      return _tag.apply(this, arguments);\n    }\n\n    return tag;\n  }()\n}), mount({\n  '/': route({\n    title: 'Tags',\n    getView: function () {\n      var _getView = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(req, context) {\n        var routes, tags, tagRoutes;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return crawlRoutes(context.blogRoot);\n\n              case 2:\n                routes = _context2.sent;\n                tags = getAvailableTagsFromRoutes(routes);\n                tagRoutes = fromPairs(tags.map(function (name) {\n                  return [name.toLowerCase(), []];\n                }));\n                routes.forEach(function (route) {\n                  var data = route.data;\n\n                  if (data && data.tags) {\n                    data.tags.forEach(function (tag) {\n                      tag = tag.toLowerCase();\n\n                      if (tagRoutes[tag]) {\n                        tagRoutes[tag].push(route);\n                      }\n                    });\n                  }\n                });\n                return _context2.abrupt(\"return\", React.createElement(TagIndexPage, {\n                  blogRoot: context.blogRoot,\n                  tags: tags.map(function (name) {\n                    return {\n                      name: name,\n                      href: join(req.mountpath, name.toLowerCase()),\n                      count: (tagRoutes[name] || []).length\n                    };\n                  }),\n                  __source: {\n                    fileName: _jsxFileName,\n                    lineNumber: 65\n                  },\n                  __self: this\n                }));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getView(_x4, _x5) {\n        return _getView.apply(this, arguments);\n      }\n\n      return getView;\n    }()\n  }),\n  '/:tag': route({\n    getTitle: function getTitle(req) {\n      return req.params.tag;\n    },\n    getView: function () {\n      var _getView2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(req, context) {\n        var lowerCaseTag, routes, tagRoutes;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                lowerCaseTag = req.params.tag.toLowerCase();\n                _context3.next = 3;\n                return crawlRoutes(context.blogRoot);\n\n              case 3:\n                routes = _context3.sent;\n                // Build a list of pages that include the tag from the site map\n                tagRoutes = [];\n                routes.forEach(function (route) {\n                  var tags = route.data && route.data.tags || [];\n\n                  if (tags.find(function (metaTag) {\n                    return metaTag.toLowerCase() === lowerCaseTag;\n                  })) {\n                    tagRoutes.push(route);\n                  }\n                });\n                return _context3.abrupt(\"return\", React.createElement(TagPage, {\n                  blogRoot: context.blogRoot,\n                  name: req.params.tag,\n                  routes: tagRoutes,\n                  __source: {\n                    fileName: _jsxFileName,\n                    lineNumber: 93\n                  },\n                  __self: this\n                }));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getView(_x6, _x7) {\n        return _getView2.apply(this, arguments);\n      }\n\n      return getView;\n    }()\n  })\n}));\n\nfunction getAvailableTagsFromRoutes(routes) {\n  var _ref;\n\n  return Array.from(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(routes.map(function (route) {\n    return route.data && route.data.tags || [];\n  })))));\n}\n\nexport default tagRoutes;","map":{"version":3,"sources":["/Users/selinaxie/Documents/AppLab/ss/portfolio/src/routes/tags.js"],"names":["React","compose","crawl","mount","resolve","route","withContext","withCrawlerPatterns","join","fromPairs","TagIndexPage","TagPage","routes","crawlRoutes","root","cache","context","crawlingRoutes","paths","method","urls","tagRoutes","req","tagsRoot","mountpath","getAvailableTagsFromRoutes","blogRoot","tag","map","title","getView","tags","name","toLowerCase","forEach","data","push","href","count","length","getTitle","params","lowerCaseTag","find","metaTag","Array","from","Set","concat"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { compose, crawl, mount, resolve, route, withContext, withCrawlerPatterns } from 'navi'\nimport { join } from 'path'\nimport { fromPairs } from 'lodash'\nimport TagIndexPage from '../components/TagIndexPage'\nimport TagPage from '../components/TagPage'\nimport routes from './index'\n\nasync function crawlRoutes(root) {\n  if (!crawlRoutes.cache[root]) {\n    let { paths } = await crawl({\n      context: {\n        crawlingRoutes: true,\n      },\n      root,\n      routes,\n    })\n    crawlRoutes.cache[root] = await resolve({\n      method: 'HEAD',\n      routes,\n      urls: paths,\n    }) \n  }\n  return crawlRoutes.cache[root]\n}\ncrawlRoutes.cache = {}\n\nconst tagRoutes = compose(\n  withContext((req, context) => ({\n    ...context,\n    tagsRoot: req.mountpath,\n  })),\n  withCrawlerPatterns({\n    '/:tag': async (req, context) => {\n      if (!context.crawlingRoutes) {\n        return getAvailableTagsFromRoutes(\n          await crawlRoutes(context.blogRoot)\n        ).map(tag => '/'+tag)\n      }\n      return []\n    }\n  }),\n  mount({\n    '/': route({\n      title: 'Tags',\n\n      getView: async (req, context) => {\n        // Build a list of pages for each tag\n        let routes = await crawlRoutes(context.blogRoot)\n        let tags = getAvailableTagsFromRoutes(routes)\n        let tagRoutes = fromPairs(tags.map(name => [name.toLowerCase(), []]))\n        routes.forEach(route => {\n          let data = route.data\n          if (data && data.tags) {\n            data.tags.forEach(tag => {\n              tag = tag.toLowerCase()\n              if (tagRoutes[tag]) {\n                tagRoutes[tag].push(route)\n              }\n            })\n          }\n        })\n\n        return (\n          <TagIndexPage\n            blogRoot={context.blogRoot}\n            tags={tags.map(name => ({\n              name,\n              href: join(req.mountpath, name.toLowerCase()),\n              count: (tagRoutes[name] || []).length,\n            }))}\n          />\n        )\n      },\n    }),\n\n    '/:tag': route({\n      getTitle: req => req.params.tag,\n      getView: async (req, context) => {\n        let lowerCaseTag = req.params.tag.toLowerCase()\n        let routes = await crawlRoutes(context.blogRoot)\n\n        // Build a list of pages that include the tag from the site map\n        let tagRoutes = []\n        routes.forEach(route => {\n          let tags = (route.data && route.data.tags) || []\n          if (tags.find(metaTag => metaTag.toLowerCase() === lowerCaseTag)) {\n            tagRoutes.push(route)\n          }\n        })\n\n        return (\n          <TagPage\n            blogRoot={context.blogRoot}\n            name={req.params.tag}\n            routes={tagRoutes}\n          />\n        )\n      },\n    }),\n  }),\n)\n\nfunction getAvailableTagsFromRoutes(routes) {\n  return Array.from(\n    new Set(\n      [].concat(...routes.map(route => (route.data && route.data.tags) || [])),\n    ),\n  )\n}\n\nexport default tagRoutes\n"]},"metadata":{},"sourceType":"module"}