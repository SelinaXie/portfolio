{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { createURLDescriptor, joinPaths, modifyTrailingSlash } from 'navi';\nimport { NaviContext } from './NaviContext';\nimport { scrollToHash } from './scrollToHash';\nexport var LinkContext = React.createContext(undefined);\n\nvar LinkAnchor =\n/** @class */\nfunction (_super) {\n  __extends(LinkAnchor, _super);\n\n  function LinkAnchor() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.renderChildren = function (context) {\n      var handleClick = context.onClick;\n\n      if (_this.props.onClick) {\n        handleClick = function handleClick(e) {\n          _this.props.onClick(e);\n\n          if (!e.defaultPrevented) {\n            context.onClick(e);\n          }\n        };\n      }\n\n      return React.createElement(\"a\", __assign({}, context, _this.props, {\n        onClick: handleClick\n      }));\n    };\n\n    return _this;\n  }\n\n  LinkAnchor.prototype.render = function () {\n    return React.createElement(LinkContext.Consumer, {\n      children: this.renderChildren\n    });\n  };\n\n  return LinkAnchor;\n}(React.Component);\n\nexport { LinkAnchor }; // Need to include this type definition, as the automatically generated one\n// is incompatible with some versions of the react typings.\n\nexport var Link = Object.assign(React.forwardRef(function (props, anchorRef) {\n  return React.createElement(NaviContext.Consumer, null, function (context) {\n    return React.createElement(InnerLink, __assign({}, props, {\n      context: context,\n      anchorRef: anchorRef\n    }));\n  });\n}), {\n  Anchor: LinkAnchor\n});\nLink.defaultProps = {\n  render: function render(props) {\n    var active = props.active,\n        activeClassName = props.activeClassName,\n        activeStyle = props.activeStyle,\n        children = props.children,\n        className = props.className,\n        hidden = props.hidden,\n        style = props.style;\n    return React.createElement(LinkAnchor, {\n      children: children,\n      className: (className || '') + \" \" + (active && activeClassName || ''),\n      hidden: hidden,\n      style: Object.assign({}, style, active ? activeStyle : {})\n    });\n  }\n};\n\nvar InnerLink =\n/** @class */\nfunction (_super) {\n  __extends(InnerLink, _super);\n\n  function InnerLink(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleClick = function (event) {\n      // Let the browser handle the event directly if:\n      // - The user used the middle/right mouse button\n      // - The user was holding a modifier key\n      // - A `target` property is set (which may cause the browser to open the\n      //   link in another tab)\n      if (event.button === 0 && !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)) {\n        if (_this.props.disabled) {\n          event.preventDefault();\n          return;\n        }\n\n        if (_this.props.onClick) {\n          _this.props.onClick(event);\n        } // Let the browser handle targets natively\n\n\n        if (_this.props.target) {\n          return;\n        }\n\n        var url = _this.getURL();\n\n        if (!event.defaultPrevented && url) {\n          event.preventDefault();\n          var currentURL = (_this.props.context.busyRoute || _this.props.context.steadyRoute).url;\n          var isSamePathname = modifyTrailingSlash(url.pathname, 'remove') === modifyTrailingSlash(currentURL.pathname, 'remove');\n\n          _this.props.context.navigation.navigate(url);\n\n          if ((isSamePathname || url.pathname === '') && url.hash === currentURL.hash && url.hash) {\n            scrollToHash(currentURL.hash, 'smooth');\n          }\n        }\n      }\n    };\n\n    var url = _this.getURL();\n\n    var navigation = props.context.navigation;\n\n    if (navigation && url && url.pathname && props.prefetch) {\n      navigation.prefetch(url).catch(function (e) {\n        console.warn(\"A <Link> tried to prefetch \\\"\" + url.pathname + \"\\\", but the \" + \"router was unable to fetch this path.\");\n      });\n    }\n\n    return _this;\n  }\n\n  InnerLink.prototype.getNavigationURL = function () {\n    var context = this.props.context;\n    var route = context.steadyRoute || context.busyRoute;\n    return route && route.url;\n  };\n\n  InnerLink.prototype.getURL = function () {\n    var href = this.props.href; // If this is an external link, return undefined so that the native\n    // response will be used.\n\n    if (!href || typeof href === 'string' && (href.indexOf('://') !== -1 || href.indexOf('mailto:') === 0)) {\n      return;\n    } // Resolve relative to the current \"directory\"\n\n\n    var navigationURL = this.getNavigationURL();\n\n    if (navigationURL && typeof href === 'string') {\n      href = href[0] === '/' ? href : joinPaths('/', navigationURL.pathname, href);\n    }\n\n    return createURLDescriptor(href);\n  };\n\n  InnerLink.prototype.render = function () {\n    var _a = this.props,\n        active = _a.active,\n        activeStyle = _a.activeStyle,\n        activeClassName = _a.activeClassName,\n        anchorRef = _a.anchorRef,\n        onClick = _a.onClick,\n        prefetch = _a.prefetch,\n        render = _a.render,\n        exact = _a.exact,\n        props = __rest(_a, [\"active\", \"activeStyle\", \"activeClassName\", \"anchorRef\", \"onClick\", \"prefetch\", \"render\", \"exact\"]);\n\n    var navigationURL = this.getNavigationURL();\n    var linkURL = this.getURL();\n    active = active !== undefined ? active : !!(linkURL && navigationURL && (exact ? linkURL.pathname === navigationURL.pathname : modifyTrailingSlash(navigationURL.pathname, 'add').indexOf(linkURL.pathname) === 0));\n\n    var context = __assign({}, props, {\n      onClick: this.handleClick,\n      ref: anchorRef,\n      href: typeof props.href === 'string' ? props.href : linkURL ? linkURL.href : ''\n    });\n\n    return React.createElement(LinkContext.Provider, {\n      value: context\n    }, render({\n      active: active,\n      activeClassName: activeClassName,\n      activeStyle: activeStyle,\n      anchorProps: context,\n      children: props.children,\n      className: props.className,\n      disabled: props.disabled,\n      tabIndex: props.tabIndex,\n      hidden: props.hidden,\n      href: linkURL ? linkURL.href : props.href,\n      id: props.id,\n      lang: props.lang,\n      style: props.style,\n      target: props.target,\n      title: props.title,\n      onClick: this.handleClick\n    }));\n  };\n\n  return InnerLink;\n}(React.Component);","map":null,"metadata":{},"sourceType":"module"}