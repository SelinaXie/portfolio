{"ast":null,"code":"import _objectSpread from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/selinaxie/Documents/AppLab/ss/portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nvar _jsxFileName = \"/Users/selinaxie/Documents/AppLab/ss/portfolio/src/routes/index.js\";\nimport { compose, lazy, map, mount, redirect, resolve, route, withContext, withView } from 'navi';\nimport React from 'react';\nimport { join } from 'path';\nimport { chunk, fromPairs } from 'lodash';\nimport BlogIndexPage from '../components/BlogIndexPage';\nimport BlogLayout from '../components/BlogLayout';\nimport BlogPostLayout from '../components/BlogPostLayout';\nimport siteMetadata from '../siteMetadata';\nimport posts from './posts'; // Split the posts into a list of chunks of the given size, and\n// then build index pages for each chunk.\n\nvar chunks = chunk(posts, siteMetadata.indexPageSize);\nvar chunkPagePairs = chunks.map(function (chunk, i) {\n  return ['/' + (i + 1), map(\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(req, context) {\n      var postRoutes, pageTitle;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(req.method === 'HEAD')) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", route());\n\n            case 2:\n              _context2.next = 4;\n              return Promise.all(chunk.map(\n              /*#__PURE__*/\n              function () {\n                var _ref2 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee(post) {\n                  var href;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          href = join(context.blogRoot, 'posts', post.slug);\n                          _context.next = 3;\n                          return resolve({\n                            // If you want to show the page content on the index page, set\n                            // this to 'GET' to be able to access it.\n                            method: 'HEAD',\n                            routes: routes,\n                            url: href\n                          });\n\n                        case 3:\n                          return _context.abrupt(\"return\", _context.sent);\n\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()));\n\n            case 4:\n              postRoutes = _context2.sent;\n              // Only add a page number to the page title after the first index page.\n              pageTitle = siteMetadata.title;\n\n              if (i > 0) {\n                pageTitle += \" \\u2013 page \".concat(i + 1);\n              }\n\n              return _context2.abrupt(\"return\", route({\n                title: pageTitle,\n                view: React.createElement(BlogIndexPage, {\n                  blogRoot: context.blogRoot,\n                  pageNumber: i + 1,\n                  pageCount: chunks.length,\n                  postRoutes: postRoutes,\n                  __source: {\n                    fileName: _jsxFileName,\n                    lineNumber: 45\n                  },\n                  __self: this\n                })\n              }));\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }())];\n});\nvar routes = compose(withContext(function (req, context) {\n  return _objectSpread({}, context, {\n    blogRoot: req.mountpath || '/'\n  });\n}), withView(function (req, context) {\n  // Check if the current page is an index page by comparing the remaining\n  // portion of the URL's pathname with the index page paths.\n  var isViewingIndex = req.path === '/' || /^\\/page\\/\\d+\\/$/.test(req.path); // Render the application-wide layout\n\n  return React.createElement(BlogLayout, {\n    blogRoot: context.blogRoot,\n    isViewingIndex: isViewingIndex,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 68\n    },\n    __self: this\n  });\n}), mount({\n  // The blog's index pages go here. The first index page is mapped to the\n  // root URL, with a redirect from \"/page/1\". Subsequent index pages are\n  // mapped to \"/page/n\".\n  '/': chunkPagePairs.shift()[1],\n  '/page': mount(_objectSpread({\n    '/1': redirect(function (req, context) {\n      return context.blogRoot;\n    })\n  }, fromPairs(chunkPagePairs))),\n  // Put posts under \"/posts\", so that they can be wrapped with a\n  // \"<BlogPostLayout />\" that configures MDX and adds a post-specific layout.\n  '/posts': compose(withView(function (req, context) {\n    return React.createElement(BlogPostLayout, {\n      blogRoot: context.blogRoot,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 87\n      },\n      __self: this\n    });\n  }), mount(fromPairs(posts.map(function (post) {\n    return ['/' + post.slug, post.getPage];\n  })))),\n  // Miscellaneous pages can be added directly to the root switch.\n  '/tags': lazy(function () {\n    return import('./tags');\n  }),\n  '/about': lazy(function () {\n    return import('./about');\n  }),\n  // Only the statically built copy of the RSS feed is intended to be opened,\n  // but the route is defined here so that the static renderer will pick it\n  // up.\n  '/rss': route()\n}));\nexport default routes;","map":{"version":3,"sources":["/Users/selinaxie/Documents/AppLab/ss/portfolio/src/routes/index.js"],"names":["compose","lazy","map","mount","redirect","resolve","route","withContext","withView","React","join","chunk","fromPairs","BlogIndexPage","BlogLayout","BlogPostLayout","siteMetadata","posts","chunks","indexPageSize","chunkPagePairs","i","req","context","method","Promise","all","post","href","blogRoot","slug","routes","url","postRoutes","pageTitle","title","view","length","mountpath","isViewingIndex","path","test","shift","getPage"],"mappings":"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","sourcesContent":["import { compose, lazy, map, mount, redirect, resolve, route, withContext, withView } from 'navi'\nimport React from 'react'\nimport { join } from 'path'\nimport { chunk, fromPairs } from 'lodash'\nimport BlogIndexPage from '../components/BlogIndexPage'\nimport BlogLayout from '../components/BlogLayout'\nimport BlogPostLayout from '../components/BlogPostLayout'\nimport siteMetadata from '../siteMetadata'\nimport posts from './posts'\n\n// Split the posts into a list of chunks of the given size, and\n// then build index pages for each chunk.\nlet chunks = chunk(posts, siteMetadata.indexPageSize)\nlet chunkPagePairs = chunks.map((chunk, i) => [\n  '/' + (i + 1),\n  map(async (req, context) => {\n    // Don't load anything when just crawling\n    if (req.method === 'HEAD') {\n      return route()\n    }\n\n    // Get metadata for all pages on this page\n    let postRoutes = await Promise.all(\n      chunk.map(async post => {\n        let href = join(context.blogRoot, 'posts', post.slug)\n        return await resolve({\n          // If you want to show the page content on the index page, set\n          // this to 'GET' to be able to access it.\n          method: 'HEAD',\n          routes,\n          url: href,\n        })\n      }),\n    )\n\n    // Only add a page number to the page title after the first index page.\n    let pageTitle = siteMetadata.title\n    if (i > 0) {\n      pageTitle += ` – page ${i + 1}`\n    }\n\n    return route({\n      title: pageTitle,\n      view: (\n        <BlogIndexPage\n          blogRoot={context.blogRoot}\n          pageNumber={i + 1}\n          pageCount={chunks.length}\n          postRoutes={postRoutes}\n        />\n      ),\n    })\n  }),\n])\n\nconst routes = compose(\n  withContext((req, context) => ({\n    ...context,\n    blogRoot: req.mountpath || '/',\n  })),\n  withView((req, context) => {\n    // Check if the current page is an index page by comparing the remaining\n    // portion of the URL's pathname with the index page paths.\n    let isViewingIndex = req.path === '/' || /^\\/page\\/\\d+\\/$/.test(req.path)\n\n    // Render the application-wide layout\n    return (\n      <BlogLayout\n        blogRoot={context.blogRoot}\n        isViewingIndex={isViewingIndex}\n      />\n    )\n  }),\n  mount({\n    // The blog's index pages go here. The first index page is mapped to the\n    // root URL, with a redirect from \"/page/1\". Subsequent index pages are\n    // mapped to \"/page/n\".\n    '/': chunkPagePairs.shift()[1],\n    '/page': mount({\n      '/1': redirect((req, context) => context.blogRoot),\n      ...fromPairs(chunkPagePairs),\n    }),\n\n    // Put posts under \"/posts\", so that they can be wrapped with a\n    // \"<BlogPostLayout />\" that configures MDX and adds a post-specific layout.\n    '/posts': compose(\n      withView((req, context) => <BlogPostLayout blogRoot={context.blogRoot} />),\n      mount(fromPairs(posts.map(post => ['/' + post.slug, post.getPage]))),\n    ),\n\n    // Miscellaneous pages can be added directly to the root switch.\n    '/tags': lazy(() => import('./tags')),\n    '/about': lazy(() => import('./about')),\n\n    // Only the statically built copy of the RSS feed is intended to be opened,\n    // but the route is defined here so that the static renderer will pick it\n    // up.\n    '/rss': route(),\n  }),\n)\n\nexport default routes\n"]},"metadata":{},"sourceType":"module"}