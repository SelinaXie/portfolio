{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { Helmet } from 'react-helmet';\nimport { NaviError } from 'navi';\nimport { NaviContext } from './NaviContext';\nimport { scrollToHash } from './scrollToHash';\nexport var View = function View(props) {\n  return React.createElement(NaviContext.Consumer, null, function (context) {\n    return React.createElement(InnerView, __assign({}, props, {\n      context: context\n    }));\n  });\n};\nView.defaultProps = {\n  hashScrollBehavior: 'smooth',\n  where: function where(Chunk) {\n    return Chunk.type === 'view';\n  }\n}; // Memoize these to stop a bizarre react-helmet infinite loop bug when titles\n// are recreated on each render\n\nvar titles = {};\n\nfunction createTitleElement(str) {\n  var title = titles[str];\n\n  if (!title) {\n    title = titles[str] = React.createElement(\"title\", null, str);\n  }\n\n  return title;\n}\n\nvar InnerView =\n/** @class */\nfunction (_super) {\n  __extends(InnerView, _super);\n\n  function InnerView(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {};\n    return _this;\n  }\n\n  InnerView.getDerivedStateFromProps = function (props, state) {\n    var route = props.context.steadyRoute || props.context.busyRoute; // If there's no steady route, then we'll need to wait until a steady\n    // route becomes available.\n\n    if (!route) {\n      return null;\n    } // Bail if nothing has changed\n\n\n    if (state.route === route && state.childContext && state.childContext.busyRoute === props.context.busyRoute) {\n      return null;\n    }\n\n    var unconsumedChunks = props.context.unconsumedSteadyRouteChunks || route.chunks;\n    var index = unconsumedChunks.findIndex(props.where);\n    var errorSearchChunks = index === -1 ? unconsumedChunks : unconsumedChunks.slice(0, index + 1);\n    var errorChunk = errorSearchChunks.find(function (Chunk) {\n      return Chunk.type === 'error';\n    });\n\n    if (errorChunk) {\n      return {\n        error: errorChunk.error || new Error(\"Unknown routing error\")\n      };\n    }\n\n    if (index === -1) {\n      return null;\n    }\n\n    var Chunk = unconsumedChunks[index]; // Find any unconsumed head content that comes before and after this\n    // Chunk.\n\n    var headAndTitleChunks = unconsumedChunks.slice(0, index).filter(function (Chunk) {\n      return Chunk.type === 'title' || Chunk.type === 'head';\n    });\n\n    for (index += 1; index < unconsumedChunks.length; index++) {\n      var Chunk_1 = unconsumedChunks[index];\n\n      if (Chunk_1.type === 'busy' || Chunk_1.type === 'error' || props.where(Chunk_1)) {\n        break;\n      }\n\n      if (Chunk_1.type === 'title' || Chunk_1.type === 'head') {\n        headAndTitleChunks.push(Chunk_1);\n      }\n    }\n\n    return {\n      Chunk: Chunk,\n      headAndTitleChunks: headAndTitleChunks,\n      route: route,\n      childContext: __assign({}, props.context, {\n        busyRoute: props.context.busyRoute,\n        unconsumedSteadyRouteChunks: unconsumedChunks.slice(index)\n      })\n    };\n  };\n\n  InnerView.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this.handleUpdate(prevState);\n  };\n\n  InnerView.prototype.componentDidMount = function () {\n    this.handleUpdate();\n  };\n\n  InnerView.prototype.handleUpdate = function (prevState) {\n    if (this.state.route && (!prevState || !prevState.route || prevState.route !== this.state.route)) {\n      var prevRoute = prevState && prevState.route;\n      var nextRoute = this.state.route;\n\n      if (nextRoute && nextRoute.type !== 'busy') {\n        if (prevRoute && nextRoute.url.pathname === prevRoute.url.pathname && nextRoute.url.search === prevRoute.url.search && nextRoute.url.hash === prevRoute.url.hash) {\n          return;\n        }\n\n        if (!this.props.disableScrolling && (!prevRoute || !prevRoute.url || prevRoute.url.hash !== nextRoute.url.hash || prevRoute.url.pathname !== nextRoute.url.pathname)) {\n          scrollToHash(nextRoute.url.hash, prevRoute && prevRoute.url && prevRoute.url.pathname === nextRoute.url.pathname ? this.props.hashScrollBehavior : 'auto');\n        }\n      }\n    }\n  };\n\n  InnerView.prototype.render = function () {\n    if (this.state.error) {\n      throw this.state.error;\n    }\n\n    var _a = this.state,\n        Chunk = _a.Chunk,\n        headAndTitleChunks = _a.headAndTitleChunks;\n\n    if (!Chunk || !Chunk.view) {\n      var Suspense = React.Suspense;\n\n      if (Suspense) {\n        throw this.props.context.navigation.getRoute();\n      } else {\n        console.warn(\"A Navi <View> component was rendered before your Navigation store's state had become steady. Consider waiting before rendering with \\\"await navigation.getRoute()\\\", or upgrading React to version 16.6 to handle this with Suspense.\");\n        return null;\n      }\n    }\n\n    var helmet = headAndTitleChunks && headAndTitleChunks.length && React.createElement.apply(React, [Helmet, null].concat(headAndTitleChunks.map(function (Chunk) {\n      return Chunk.type === 'title' ? createTitleElement(Chunk.title) : Chunk.head.type === React.Fragment || Chunk.head.type === 'head' ? Chunk.head.props.children : Chunk.head;\n    })));\n    var content;\n    var render;\n\n    if (this.props.children) {\n      render = this.props.children;\n\n      if (typeof render !== \"function\") {\n        throw new Error(\"A Navi <View> expects any children to be a function, but instead received \\\"\" + render + \"\\\".\");\n      }\n\n      content = this.props.children(Chunk.view, this.state.route);\n    } else if (Chunk.view) {\n      if (typeof Chunk.view === 'function') {\n        content = React.createElement(Chunk.view, {\n          route: this.props.context.steadyRoute\n        });\n      } else if (typeof Chunk.view === 'string' || React.isValidElement(Chunk.view)) {\n        content = Chunk.view;\n      }\n    } else {\n      throw new Error(\"A Navi <View> was not able to find a `children` prop, and was unable to find any body or head content in the consumed Route Chunk's `content`.\");\n    }\n\n    return React.createElement(NaviContext.Provider, {\n      value: this.state.childContext\n    }, helmet || null, // Clone the content to force a re-render even if content hasn't\n    // changed, as Provider is a PureComponent.\n    React.isValidElement(content) ? React.cloneElement(content) : content);\n  };\n\n  return InnerView;\n}(React.Component);\n\nvar MissingChunk =\n/** @class */\nfunction (_super) {\n  __extends(MissingChunk, _super);\n\n  function MissingChunk(context) {\n    var _this = _super.call(this, \"A Navi <View> component attempted to use a Chunk that couldn't be found. This is likely due to its \\\"where\\\" prop.\") || this;\n\n    _this.context = context;\n    return _this;\n  }\n\n  return MissingChunk;\n}(NaviError);\n\nexport { MissingChunk };","map":null,"metadata":{},"sourceType":"module"}